/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Bacalhau API
 * This page is the reference of the Bacalhau REST API. Project docs are available at https://docs.bacalhau.org/. Find more information about Bacalhau at https://github.com/filecoin-project/bacalhau.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: team@bacalhau.org
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://bootstrap.production.bacalhau.org:1234/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ComputenodeActiveJob
 */
export interface ComputenodeActiveJob {
    /**
     * 
     * @type {ModelResourceUsageData}
     * @memberof ComputenodeActiveJob
     */
    capacityRequirements?: ModelResourceUsageData;
    /**
     * 
     * @type {string}
     * @memberof ComputenodeActiveJob
     */
    shardID?: string;
    /**
     * 
     * @type {string}
     * @memberof ComputenodeActiveJob
     */
    state?: string;
}
/**
 * 
 * @export
 * @interface ModelBuildVersionInfo
 */
export interface ModelBuildVersionInfo {
    /**
     * 
     * @type {string}
     * @memberof ModelBuildVersionInfo
     */
    builddate?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelBuildVersionInfo
     */
    gitcommit?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelBuildVersionInfo
     */
    gitversion?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelBuildVersionInfo
     */
    goarch?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelBuildVersionInfo
     */
    goos?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelBuildVersionInfo
     */
    major?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelBuildVersionInfo
     */
    minor?: string;
}
/**
 * 
 * @export
 * @interface ModelDeal
 */
export interface ModelDeal {
    /**
     * The maximum number of concurrent compute node bids that will be accepted by the requester node on behalf of the client.
     * @type {number}
     * @memberof ModelDeal
     */
    concurrency?: number;
    /**
     * The number of nodes that must agree on a verification result this is used by the different verifiers - for example the deterministic verifier requires the winning group size to be at least this size
     * @type {number}
     * @memberof ModelDeal
     */
    confidence?: number;
    /**
     * The minimum number of bids that must be received before the Requester node will randomly accept concurrency-many of them. This allows the Requester node to get some level of guarantee that the execution of the jobs will be spread evenly across the network (assuming that this value is some large proportion of the size of the network).
     * @type {number}
     * @memberof ModelDeal
     */
    minBids?: number;
}
/**
 * 
 * @export
 * @interface ModelJob
 */
export interface ModelJob {
    /**
     * 
     * @type {string}
     * @memberof ModelJob
     */
    aPIVersion?: string;
    /**
     * The ID of the client that created this job.
     * @type {string}
     * @memberof ModelJob
     */
    clientID?: string;
    /**
     * Time the job was submitted to the bacalhau network.
     * @type {string}
     * @memberof ModelJob
     */
    createdAt?: string;
    /**
     * 
     * @type {ModelDeal}
     * @memberof ModelJob
     */
    deal?: ModelDeal;
    /**
     * 
     * @type {ModelJobExecutionPlan}
     * @memberof ModelJob
     */
    executionPlan?: ModelJobExecutionPlan;
    /**
     * The unique global ID of this job in the bacalhau network.
     * @type {string}
     * @memberof ModelJob
     */
    ID?: string;
    /**
     * All events associated with the job
     * @type {Array<ModelJobEvent>}
     * @memberof ModelJob
     */
    jobEvents?: Array<ModelJobEvent>;
    /**
     * 
     * @type {ModelJobState}
     * @memberof ModelJob
     */
    jobState?: ModelJobState;
    /**
     * All local events associated with the job
     * @type {Array<ModelJobLocalEvent>}
     * @memberof ModelJob
     */
    localJobEvents?: Array<ModelJobLocalEvent>;
    /**
     * The ID of the requester node that owns this job.
     * @type {string}
     * @memberof ModelJob
     */
    requesterNodeID?: string;
    /**
     * The public key of the Requester node that created this job This can be used to encrypt messages back to the creator
     * @type {Array<number>}
     * @memberof ModelJob
     */
    requesterPublicKey?: Array<number>;
    /**
     * 
     * @type {ModelSpec}
     * @memberof ModelJob
     */
    spec?: ModelSpec;
}
/**
 * 
 * @export
 * @interface ModelJobCreatePayload
 */
export interface ModelJobCreatePayload {
    /**
     * the id of the client that is submitting the job
     * @type {string}
     * @memberof ModelJobCreatePayload
     */
    clientID: string;
    /**
     * Optional base64-encoded tar file that will be pinned to IPFS and mounted as storage for the job. Not part of the spec so we don't flood the transport layer with it (potentially very large).
     * @type {string}
     * @memberof ModelJobCreatePayload
     */
    context?: string;
    /**
     * 
     * @type {ModelJob}
     * @memberof ModelJobCreatePayload
     */
    job: ModelJob;
}
/**
 * 
 * @export
 * @interface ModelJobEvent
 */
export interface ModelJobEvent {
    /**
     * APIVersion of the Job
     * @type {string}
     * @memberof ModelJobEvent
     */
    aPIVersion?: string;
    /**
     * optional clientID if this is an externally triggered event (like create job)
     * @type {string}
     * @memberof ModelJobEvent
     */
    clientID?: string;
    /**
     * 
     * @type {ModelDeal}
     * @memberof ModelJobEvent
     */
    deal?: ModelDeal;
    /**
     * 
     * @type {number}
     * @memberof ModelJobEvent
     */
    eventName?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelJobEvent
     */
    eventTime?: string;
    /**
     * 
     * @type {ModelJobExecutionPlan}
     * @memberof ModelJobEvent
     */
    jobExecutionPlan?: ModelJobExecutionPlan;
    /**
     * 
     * @type {string}
     * @memberof ModelJobEvent
     */
    jobID?: string;
    /**
     * 
     * @type {ModelStorageSpec}
     * @memberof ModelJobEvent
     */
    publishedResult?: ModelStorageSpec;
    /**
     * 
     * @type {ModelRunCommandResult}
     * @memberof ModelJobEvent
     */
    runOutput?: ModelRunCommandResult;
    /**
     * 
     * @type {Array<number>}
     * @memberof ModelJobEvent
     */
    senderPublicKey?: Array<number>;
    /**
     * what shard is this event for
     * @type {number}
     * @memberof ModelJobEvent
     */
    shardIndex?: number;
    /**
     * the node that emitted this event
     * @type {string}
     * @memberof ModelJobEvent
     */
    sourceNodeID?: string;
    /**
     * 
     * @type {ModelSpec}
     * @memberof ModelJobEvent
     */
    spec?: ModelSpec;
    /**
     * 
     * @type {string}
     * @memberof ModelJobEvent
     */
    status?: string;
    /**
     * the node that this event is for e.g. \"AcceptJobBid\" was emitted by Requester but it targeting compute node
     * @type {string}
     * @memberof ModelJobEvent
     */
    targetNodeID?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ModelJobEvent
     */
    verificationProposal?: Array<number>;
    /**
     * 
     * @type {ModelVerificationResult}
     * @memberof ModelJobEvent
     */
    verificationResult?: ModelVerificationResult;
}
/**
 * 
 * @export
 * @interface ModelJobExecutionPlan
 */
export interface ModelJobExecutionPlan {
    /**
     * how many shards are there in total for this job we are expecting this number x concurrency total JobShardState objects for this job
     * @type {number}
     * @memberof ModelJobExecutionPlan
     */
    shardsTotal?: number;
}
/**
 * 
 * @export
 * @interface ModelJobLocalEvent
 */
export interface ModelJobLocalEvent {
    /**
     * 
     * @type {number}
     * @memberof ModelJobLocalEvent
     */
    eventName?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelJobLocalEvent
     */
    jobID?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelJobLocalEvent
     */
    shardIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelJobLocalEvent
     */
    targetNodeID?: string;
}
/**
 * 
 * @export
 * @interface ModelJobNodeState
 */
export interface ModelJobNodeState {
    /**
     * 
     * @type {{ [key: string]: ModelJobShardState; }}
     * @memberof ModelJobNodeState
     */
    shards?: { [key: string]: ModelJobShardState; };
}
/**
 * 
 * @export
 * @interface ModelJobShardState
 */
export interface ModelJobShardState {
    /**
     * which node is running this shard
     * @type {string}
     * @memberof ModelJobShardState
     */
    nodeId?: string;
    /**
     * 
     * @type {ModelStorageSpec}
     * @memberof ModelJobShardState
     */
    publishedResults?: ModelStorageSpec;
    /**
     * 
     * @type {ModelRunCommandResult}
     * @memberof ModelJobShardState
     */
    runOutput?: ModelRunCommandResult;
    /**
     * what shard is this we are running
     * @type {number}
     * @memberof ModelJobShardState
     */
    shardIndex?: number;
    /**
     * what is the state of the shard on this node
     * @type {number}
     * @memberof ModelJobShardState
     */
    state?: number;
    /**
     * an arbitrary status message
     * @type {string}
     * @memberof ModelJobShardState
     */
    status?: string;
    /**
     * the proposed results for this shard this will be resolved by the verifier somehow
     * @type {Array<number>}
     * @memberof ModelJobShardState
     */
    verificationProposal?: Array<number>;
    /**
     * 
     * @type {ModelVerificationResult}
     * @memberof ModelJobShardState
     */
    verificationResult?: ModelVerificationResult;
}
/**
 * 
 * @export
 * @interface ModelJobShardingConfig
 */
export interface ModelJobShardingConfig {
    /**
     * how many \"items\" are to be processed in each shard we first apply the glob pattern which will result in a flat list of items this number decides how to group that flat list into actual shards run by compute nodes
     * @type {number}
     * @memberof ModelJobShardingConfig
     */
    batchSize?: number;
    /**
     * divide the inputs up into the smallest possible unit for example /_* would mean \"all top level files or folders\" this being an empty string means \"no sharding\"
     * @type {string}
     * @memberof ModelJobShardingConfig
     */
    globPattern?: string;
    /**
     * when using multiple input volumes what path do we treat as the common mount path to apply the glob pattern to
     * @type {string}
     * @memberof ModelJobShardingConfig
     */
    globPatternBasePath?: string;
}
/**
 * 
 * @export
 * @interface ModelJobSpecDocker
 */
export interface ModelJobSpecDocker {
    /**
     * optionally override the default entrypoint
     * @type {Array<string>}
     * @memberof ModelJobSpecDocker
     */
    entrypoint?: Array<string>;
    /**
     * a map of env to run the container with
     * @type {Array<string>}
     * @memberof ModelJobSpecDocker
     */
    environmentVariables?: Array<string>;
    /**
     * this should be pullable by docker
     * @type {string}
     * @memberof ModelJobSpecDocker
     */
    image?: string;
    /**
     * working directory inside the container
     * @type {string}
     * @memberof ModelJobSpecDocker
     */
    workingDirectory?: string;
}
/**
 * 
 * @export
 * @interface ModelJobSpecLanguage
 */
export interface ModelJobSpecLanguage {
    /**
     * optional program specified on commandline, like python -c \"print(1+1)\"
     * @type {string}
     * @memberof ModelJobSpecLanguage
     */
    command?: string;
    /**
     * must this job be run in a deterministic context?
     * @type {boolean}
     * @memberof ModelJobSpecLanguage
     */
    deterministicExecution?: boolean;
    /**
     * 
     * @type {ModelStorageSpec}
     * @memberof ModelJobSpecLanguage
     */
    jobContext?: ModelStorageSpec;
    /**
     * e.g. python
     * @type {string}
     * @memberof ModelJobSpecLanguage
     */
    language?: string;
    /**
     * e.g. 3.8
     * @type {string}
     * @memberof ModelJobSpecLanguage
     */
    languageVersion?: string;
    /**
     * optional program path relative to the context dir. one of Command or ProgramPath must be specified
     * @type {string}
     * @memberof ModelJobSpecLanguage
     */
    programPath?: string;
    /**
     * optional requirements.txt (or equivalent) path relative to the context dir
     * @type {string}
     * @memberof ModelJobSpecLanguage
     */
    requirementsPath?: string;
}
/**
 * 
 * @export
 * @interface ModelJobSpecWasm
 */
export interface ModelJobSpecWasm {
    /**
     * The name of the function in the EntryModule to call to run the job. For WASI jobs, this will always be `_start`, but jobs can choose to call other WASM functions instead. The EntryPoint must be a zero-parameter zero-result function.
     * @type {string}
     * @memberof ModelJobSpecWasm
     */
    entryPoint?: string;
    /**
     * The variables available in the environment of the running program.
     * @type {{ [key: string]: string; }}
     * @memberof ModelJobSpecWasm
     */
    environmentVariables?: { [key: string]: string; };
    /**
     * TODO #880: Other WASM modules whose exports will be available as imports to the EntryModule.
     * @type {Array<ModelStorageSpec>}
     * @memberof ModelJobSpecWasm
     */
    importModules?: Array<ModelStorageSpec>;
    /**
     * The arguments supplied to the program (i.e. as ARGV).
     * @type {Array<string>}
     * @memberof ModelJobSpecWasm
     */
    parameters?: Array<string>;
}
/**
 * 
 * @export
 * @interface ModelJobState
 */
export interface ModelJobState {
    /**
     * 
     * @type {{ [key: string]: ModelJobNodeState; }}
     * @memberof ModelJobState
     */
    nodes?: { [key: string]: ModelJobNodeState; };
}
/**
 * 
 * @export
 * @interface ModelPublishedResult
 */
export interface ModelPublishedResult {
    /**
     * 
     * @type {ModelStorageSpec}
     * @memberof ModelPublishedResult
     */
    data?: ModelStorageSpec;
    /**
     * 
     * @type {string}
     * @memberof ModelPublishedResult
     */
    nodeID?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelPublishedResult
     */
    shardIndex?: number;
}
/**
 * 
 * @export
 * @interface ModelResourceUsageConfig
 */
export interface ModelResourceUsageConfig {
    /**
     * https://github.com/BTBurke/k8sresource string
     * @type {string}
     * @memberof ModelResourceUsageConfig
     */
    CPU?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelResourceUsageConfig
     */
    disk?: string;
    /**
     * unsigned integer string
     * @type {string}
     * @memberof ModelResourceUsageConfig
     */
    GPU?: string;
    /**
     * github.com/c2h5oh/datasize string
     * @type {string}
     * @memberof ModelResourceUsageConfig
     */
    memory?: string;
}
/**
 * 
 * @export
 * @interface ModelResourceUsageData
 */
export interface ModelResourceUsageData {
    /**
     * cpu units
     * @type {number}
     * @memberof ModelResourceUsageData
     */
    CPU?: number;
    /**
     * bytes
     * @type {number}
     * @memberof ModelResourceUsageData
     */
    disk?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelResourceUsageData
     */
    GPU?: number;
    /**
     * bytes
     * @type {number}
     * @memberof ModelResourceUsageData
     */
    memory?: number;
}
/**
 * 
 * @export
 * @interface ModelRunCommandResult
 */
export interface ModelRunCommandResult {
    /**
     * exit code of the run.
     * @type {number}
     * @memberof ModelRunCommandResult
     */
    exitCode?: number;
    /**
     * Runner error
     * @type {string}
     * @memberof ModelRunCommandResult
     */
    runnerError?: string;
    /**
     * stderr of the run.
     * @type {string}
     * @memberof ModelRunCommandResult
     */
    stderr?: string;
    /**
     * bool describing if stderr was truncated
     * @type {boolean}
     * @memberof ModelRunCommandResult
     */
    stderrtruncated?: boolean;
    /**
     * stdout of the run. Yaml provided for `describe` output
     * @type {string}
     * @memberof ModelRunCommandResult
     */
    stdout?: string;
    /**
     * bool describing if stdout was truncated
     * @type {boolean}
     * @memberof ModelRunCommandResult
     */
    stdouttruncated?: boolean;
}
/**
 * 
 * @export
 * @interface ModelSpec
 */
export interface ModelSpec {
    /**
     * Annotations on the job - could be user or machine assigned
     * @type {Array<string>}
     * @memberof ModelSpec
     */
    annotations?: Array<string>;
    /**
     * Input volumes that will not be sharded for example to upload code into a base image every shard will get the full range of context volumes
     * @type {Array<ModelStorageSpec>}
     * @memberof ModelSpec
     */
    contexts?: Array<ModelStorageSpec>;
    /**
     * Do not track specified by the client
     * @type {boolean}
     * @memberof ModelSpec
     */
    doNotTrack?: boolean;
    /**
     * 
     * @type {ModelJobSpecDocker}
     * @memberof ModelSpec
     */
    docker?: ModelJobSpecDocker;
    /**
     * e.g. docker or language
     * @type {number}
     * @memberof ModelSpec
     */
    engine?: number;
    /**
     * 
     * @type {ModelJobSpecLanguage}
     * @memberof ModelSpec
     */
    language?: ModelJobSpecLanguage;
    /**
     * there can be multiple publishers for the job
     * @type {number}
     * @memberof ModelSpec
     */
    publisher?: number;
    /**
     * 
     * @type {ModelResourceUsageConfig}
     * @memberof ModelSpec
     */
    resources?: ModelResourceUsageConfig;
    /**
     * 
     * @type {ModelJobShardingConfig}
     * @memberof ModelSpec
     */
    sharding?: ModelJobShardingConfig;
    /**
     * How long a job can run in seconds before it is killed. This includes the time required to run, verify and publish results
     * @type {number}
     * @memberof ModelSpec
     */
    timeout?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelSpec
     */
    verifier?: number;
    /**
     * 
     * @type {ModelJobSpecWasm}
     * @memberof ModelSpec
     */
    wasm?: ModelJobSpecWasm;
    /**
     * the data volumes we will read in the job for example \"read this ipfs cid\" TODO: #667 Replace with \"Inputs\", \"Outputs\" (note the caps) for yaml/json when we update the n.js file
     * @type {Array<ModelStorageSpec>}
     * @memberof ModelSpec
     */
    inputs?: Array<ModelStorageSpec>;
    /**
     * the data volumes we will write in the job for example \"write the results to ipfs\"
     * @type {Array<ModelStorageSpec>}
     * @memberof ModelSpec
     */
    outputs?: Array<ModelStorageSpec>;
}
/**
 * 
 * @export
 * @interface ModelStorageSpec
 */
export interface ModelStorageSpec {
    /**
     * The unique ID of the data, where it makes sense (for example, in an IPFS storage spec this will be the data's CID). NOTE: The below is capitalized to match IPFS & IPLD (even though it's out of golang fmt)
     * @type {string}
     * @memberof ModelStorageSpec
     */
    CID?: string;
    /**
     * Additional properties specific to each driver
     * @type {{ [key: string]: string; }}
     * @memberof ModelStorageSpec
     */
    metadata?: { [key: string]: string; };
    /**
     * Name of the spec's data, for reference.
     * @type {string}
     * @memberof ModelStorageSpec
     */
    name?: string;
    /**
     * StorageSource is the abstract source of the data. E.g. a storage source might be a URL download, but doesn't specify how the execution engine does the download or what it will do with the downloaded data.
     * @type {number}
     * @memberof ModelStorageSpec
     */
    storageSource?: number;
    /**
     * Source URL of the data
     * @type {string}
     * @memberof ModelStorageSpec
     */
    URL?: string;
    /**
     * The path that the spec's data should be mounted on, where it makes sense (for example, in a Docker storage spec this will be a filesystem path). TODO: #668 Replace with \"Path\" (note the caps) for yaml/json when we update the n.js file
     * @type {string}
     * @memberof ModelStorageSpec
     */
    path?: string;
}
/**
 * 
 * @export
 * @interface ModelVerificationResult
 */
export interface ModelVerificationResult {
    /**
     * 
     * @type {boolean}
     * @memberof ModelVerificationResult
     */
    complete?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModelVerificationResult
     */
    result?: boolean;
}
/**
 * 
 * @export
 * @interface PublicapiDebugResponse
 */
export interface PublicapiDebugResponse {
    /**
     * 
     * @type {ModelResourceUsageData}
     * @memberof PublicapiDebugResponse
     */
    availableComputeCapacity?: ModelResourceUsageData;
    /**
     * 
     * @type {Array<ComputenodeActiveJob>}
     * @memberof PublicapiDebugResponse
     */
    computeJobs?: Array<ComputenodeActiveJob>;
    /**
     * 
     * @type {Array<RequesternodeActiveJob>}
     * @memberof PublicapiDebugResponse
     */
    requesterJobs?: Array<RequesternodeActiveJob>;
}
/**
 * 
 * @export
 * @interface PublicapiEventsRequest
 */
export interface PublicapiEventsRequest {
    /**
     * 
     * @type {string}
     * @memberof PublicapiEventsRequest
     */
    clientId?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicapiEventsRequest
     */
    jobId?: string;
}
/**
 * 
 * @export
 * @interface PublicapiEventsResponse
 */
export interface PublicapiEventsResponse {
    /**
     * 
     * @type {Array<ModelJobEvent>}
     * @memberof PublicapiEventsResponse
     */
    events?: Array<ModelJobEvent>;
}
/**
 * 
 * @export
 * @interface PublicapiListRequest
 */
export interface PublicapiListRequest {
    /**
     * 
     * @type {string}
     * @memberof PublicapiListRequest
     */
    clientId?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicapiListRequest
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof PublicapiListRequest
     */
    maxJobs?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PublicapiListRequest
     */
    returnAll?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PublicapiListRequest
     */
    sortBy?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PublicapiListRequest
     */
    sortReverse?: boolean;
}
/**
 * 
 * @export
 * @interface PublicapiListResponse
 */
export interface PublicapiListResponse {
    /**
     * 
     * @type {Array<ModelJob>}
     * @memberof PublicapiListResponse
     */
    jobs?: Array<ModelJob>;
}
/**
 * 
 * @export
 * @interface PublicapiLocalEventsRequest
 */
export interface PublicapiLocalEventsRequest {
    /**
     * 
     * @type {string}
     * @memberof PublicapiLocalEventsRequest
     */
    clientId?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicapiLocalEventsRequest
     */
    jobId?: string;
}
/**
 * 
 * @export
 * @interface PublicapiLocalEventsResponse
 */
export interface PublicapiLocalEventsResponse {
    /**
     * 
     * @type {Array<ModelJobLocalEvent>}
     * @memberof PublicapiLocalEventsResponse
     */
    localEvents?: Array<ModelJobLocalEvent>;
}
/**
 * 
 * @export
 * @interface PublicapiResultsResponse
 */
export interface PublicapiResultsResponse {
    /**
     * 
     * @type {Array<ModelPublishedResult>}
     * @memberof PublicapiResultsResponse
     */
    results?: Array<ModelPublishedResult>;
}
/**
 * 
 * @export
 * @interface PublicapiStateRequest
 */
export interface PublicapiStateRequest {
    /**
     * 
     * @type {string}
     * @memberof PublicapiStateRequest
     */
    clientId?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicapiStateRequest
     */
    jobId?: string;
}
/**
 * 
 * @export
 * @interface PublicapiStateResponse
 */
export interface PublicapiStateResponse {
    /**
     * 
     * @type {ModelJobState}
     * @memberof PublicapiStateResponse
     */
    state?: ModelJobState;
}
/**
 * 
 * @export
 * @interface PublicapiSubmitRequest
 */
export interface PublicapiSubmitRequest {
    /**
     * The base64-encoded public key of the client:
     * @type {string}
     * @memberof PublicapiSubmitRequest
     */
    clientPublicKey: string;
    /**
     * 
     * @type {ModelJobCreatePayload}
     * @memberof PublicapiSubmitRequest
     */
    data: ModelJobCreatePayload;
    /**
     * A base64-encoded signature of the data, signed by the client:
     * @type {string}
     * @memberof PublicapiSubmitRequest
     */
    signature: string;
}
/**
 * 
 * @export
 * @interface PublicapiSubmitResponse
 */
export interface PublicapiSubmitResponse {
    /**
     * 
     * @type {ModelJob}
     * @memberof PublicapiSubmitResponse
     */
    job?: ModelJob;
}
/**
 * 
 * @export
 * @interface PublicapiVersionRequest
 */
export interface PublicapiVersionRequest {
    /**
     * 
     * @type {string}
     * @memberof PublicapiVersionRequest
     */
    clientId?: string;
}
/**
 * 
 * @export
 * @interface PublicapiVersionResponse
 */
export interface PublicapiVersionResponse {
    /**
     * 
     * @type {ModelBuildVersionInfo}
     * @memberof PublicapiVersionResponse
     */
    buildVersionInfo?: ModelBuildVersionInfo;
}
/**
 * 
 * @export
 * @interface RequesternodeActiveJob
 */
export interface RequesternodeActiveJob {
    /**
     * 
     * @type {number}
     * @memberof RequesternodeActiveJob
     */
    biddingNodesCount?: number;
    /**
     * 
     * @type {number}
     * @memberof RequesternodeActiveJob
     */
    completedNodesCount?: number;
    /**
     * 
     * @type {string}
     * @memberof RequesternodeActiveJob
     */
    shardID?: string;
    /**
     * 
     * @type {string}
     * @memberof RequesternodeActiveJob
     */
    state?: string;
}
/**
 * 
 * @export
 * @interface TypesFreeSpace
 */
export interface TypesFreeSpace {
    /**
     * 
     * @type {TypesMountStatus}
     * @memberof TypesFreeSpace
     */
    iPFSMount?: TypesMountStatus;
    /**
     * 
     * @type {TypesMountStatus}
     * @memberof TypesFreeSpace
     */
    root?: TypesMountStatus;
    /**
     * 
     * @type {TypesMountStatus}
     * @memberof TypesFreeSpace
     */
    tmp?: TypesMountStatus;
}
/**
 * 
 * @export
 * @interface TypesHealthInfo
 */
export interface TypesHealthInfo {
    /**
     * 
     * @type {TypesFreeSpace}
     * @memberof TypesHealthInfo
     */
    freeSpace?: TypesFreeSpace;
}
/**
 * 
 * @export
 * @interface TypesMountStatus
 */
export interface TypesMountStatus {
    /**
     * 
     * @type {number}
     * @memberof TypesMountStatus
     */
    all?: number;
    /**
     * 
     * @type {number}
     * @memberof TypesMountStatus
     */
    free?: number;
    /**
     * 
     * @type {number}
     * @memberof TypesMountStatus
     */
    used?: number;
}
/**
 * HealthApi - fetch parameter creator
 * @export
 */
export const HealthApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns debug information on what the current node is doing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerdebug(options: any = {}): FetchArgs {
            const localVarPath = `/debug`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerhealthz(options: any = {}): FetchArgs {
            const localVarPath = `/healthz`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerlivez(options: any = {}): FetchArgs {
            const localVarPath = `/livez`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerlogz(options: any = {}): FetchArgs {
            const localVarPath = `/logz`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerreadyz(options: any = {}): FetchArgs {
            const localVarPath = `/readyz`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServervarz(options: any = {}): FetchArgs {
            const localVarPath = `/varz`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns debug information on what the current node is doing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerdebug(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PublicapiDebugResponse> {
            const localVarFetchArgs = HealthApiFetchParamCreator(configuration).apiServerdebug(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerhealthz(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TypesHealthInfo> {
            const localVarFetchArgs = HealthApiFetchParamCreator(configuration).apiServerhealthz(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerlivez(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = HealthApiFetchParamCreator(configuration).apiServerlivez(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerlogz(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = HealthApiFetchParamCreator(configuration).apiServerlogz(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerreadyz(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = HealthApiFetchParamCreator(configuration).apiServerreadyz(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServervarz(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = HealthApiFetchParamCreator(configuration).apiServervarz(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Returns debug information on what the current node is doing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerdebug(options?: any) {
            return HealthApiFp(configuration).apiServerdebug(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerhealthz(options?: any) {
            return HealthApiFp(configuration).apiServerhealthz(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerlivez(options?: any) {
            return HealthApiFp(configuration).apiServerlivez(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerlogz(options?: any) {
            return HealthApiFp(configuration).apiServerlogz(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerreadyz(options?: any) {
            return HealthApiFp(configuration).apiServerreadyz(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServervarz(options?: any) {
            return HealthApiFp(configuration).apiServervarz(options)(fetch, basePath);
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary Returns debug information on what the current node is doing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public apiServerdebug(options?: any) {
        return HealthApiFp(this.configuration).apiServerdebug(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public apiServerhealthz(options?: any) {
        return HealthApiFp(this.configuration).apiServerhealthz(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public apiServerlivez(options?: any) {
        return HealthApiFp(this.configuration).apiServerlivez(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public apiServerlogz(options?: any) {
        return HealthApiFp(this.configuration).apiServerlogz(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public apiServerreadyz(options?: any) {
        return HealthApiFp(this.configuration).apiServerreadyz(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public apiServervarz(options?: any) {
        return HealthApiFp(this.configuration).apiServervarz(options)(this.fetch, this.basePath);
    }

}
/**
 * JobApi - fetch parameter creator
 * @export
 */
export const JobApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Description:  * `client_public_key`: The base64-encoded public key of the client. * `signature`: A base64-encoded signature of the `data` attribute, signed by the client. * `data`     * `ClientID`: Request must specify a `ClientID`. To retrieve your `ClientID`, you can do the following: (1) submit a dummy job to Bacalhau (or use one you created before), (2) run `bacalhau describe <job-id>` and fetch the `ClientID` field.     * `Job`: see example below.  Example request ```json {  \"data\": {   \"ClientID\": \"ac13188e93c97a9c2e7cf8e86c7313156a73436036f30da1ececc2ce79f9ea51\",   \"Job\": {    \"APIVersion\": \"V1beta1\",    \"Spec\": {     \"Engine\": \"Docker\",     \"Verifier\": \"Noop\",     \"Publisher\": \"Estuary\",     \"Docker\": {      \"Image\": \"ubuntu\",      \"Entrypoint\": [       \"date\"      ]     },     \"Timeout\": 1800,     \"outputs\": [      {       \"StorageSource\": \"IPFS\",       \"Name\": \"outputs\",       \"path\": \"/outputs\"      }     ],     \"Sharding\": {      \"BatchSize\": 1,      \"GlobPatternBasePath\": \"/inputs\"     }    },    \"Deal\": {     \"Concurrency\": 1    }   }  },  \"signature\": \"...\",  \"client_public_key\": \"...\" } ```
         * @summary Submits a new job to the network.
         * @param {PublicapiSubmitRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pkgapiServerSubmit(body: PublicapiSubmitRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling pkgapiServerSubmit.');
            }
            const localVarPath = `/submit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PublicapiSubmitRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the first (sorted) #`max_jobs` jobs that belong to the `client_id` passed in the body payload (by default). If `return_all` is set to true, it returns all jobs on the Bacalhau network.  If `id` is set, it returns only the job with that ID.  Example response: ```json {   \"jobs\": [     {       \"APIVersion\": \"V1beta1\",       \"ID\": \"9304c616-291f-41ad-b862-54e133c0149e\",       \"RequesterNodeID\": \"QmXaXu9N5GNetatsvwnTfQqNtSeKAD6uCmarbh3LMRYAcF\",       \"RequesterPublicKey\": \"...\",       \"ClientID\": \"ac13188e93c97a9c2e7cf8e86c7313156a73436036f30da1ececc2ce79f9ea51\",       \"Spec\": {         \"Engine\": \"Docker\",         \"Verifier\": \"Noop\",         \"Publisher\": \"Estuary\",         \"Docker\": {           \"Image\": \"ubuntu\",           \"Entrypoint\": [             \"date\"           ]         },         \"Language\": {           \"JobContext\": {}         },         \"Wasm\": {},         \"Resources\": {           \"GPU\": \"\"         },         \"Timeout\": 1800,         \"outputs\": [           {             \"StorageSource\": \"IPFS\",             \"Name\": \"outputs\",             \"path\": \"/outputs\"           }         ],         \"Sharding\": {           \"BatchSize\": 1,           \"GlobPatternBasePath\": \"/inputs\"         }       },       \"Deal\": {         \"Concurrency\": 1       },       \"ExecutionPlan\": {         \"ShardsTotal\": 1       },       \"CreatedAt\": \"2022-11-17T13:32:55.33837275Z\",       \"JobState\": {         \"Nodes\": {           \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\": {             \"Shards\": {               \"0\": {                 \"NodeId\": \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\",                 \"State\": \"Cancelled\",                 \"VerificationResult\": {},                 \"PublishedResults\": {}               }             }           },           \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\": {             \"Shards\": {               \"0\": {                 \"NodeId\": \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\",                 \"State\": \"Cancelled\",                 \"VerificationResult\": {},                 \"PublishedResults\": {}               }             }           },           \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\": {             \"Shards\": {               \"0\": {                 \"NodeId\": \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",                 \"State\": \"Completed\",                 \"Status\": \"Got results proposal of length: 0\",                 \"VerificationResult\": {                   \"Complete\": true,                   \"Result\": true                 },                 \"PublishedResults\": {                   \"StorageSource\": \"IPFS\",                   \"Name\": \"job-9304c616-291f-41ad-b862-54e133c0149e-shard-0-host-QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",                   \"CID\": \"QmTVmC7JBD2ES2qGPqBNVWnX1KeEPNrPGb7rJ8cpFgtefe\"                 },                 \"RunOutput\": {                   \"stdout\": \"Thu Nov 17 13:32:55 UTC 2022\\n\",                   \"stdouttruncated\": false,                   \"stderr\": \"\",                   \"stderrtruncated\": false,                   \"exitCode\": 0,                   \"runnerError\": \"\"                 }               }             }           }         }       }     },     {       \"APIVersion\": \"V1beta1\",       \"ID\": \"92d5d4ee-3765-4f78-8353-623f5f26df08\",       \"RequesterNodeID\": \"QmXaXu9N5GNetatsvwnTfQqNtSeKAD6uCmarbh3LMRYAcF\",       \"RequesterPublicKey\": \"...\",       \"ClientID\": \"ac13188e93c97a9c2e7cf8e86c7313156a73436036f30da1ececc2ce79f9ea51\",       \"Spec\": {         \"Engine\": \"Docker\",         \"Verifier\": \"Noop\",         \"Publisher\": \"Estuary\",         \"Docker\": {           \"Image\": \"ubuntu\",           \"Entrypoint\": [             \"sleep\",             \"4\"           ]         },         \"Language\": {           \"JobContext\": {}         },         \"Wasm\": {},         \"Resources\": {           \"GPU\": \"\"         },         \"Timeout\": 1800,         \"outputs\": [           {             \"StorageSource\": \"IPFS\",             \"Name\": \"outputs\",             \"path\": \"/outputs\"           }         ],         \"Sharding\": {           \"BatchSize\": 1,           \"GlobPatternBasePath\": \"/inputs\"         }       },       \"Deal\": {         \"Concurrency\": 1       },       \"ExecutionPlan\": {         \"ShardsTotal\": 1       },       \"CreatedAt\": \"2022-11-17T13:29:01.871140291Z\",       \"JobState\": {         \"Nodes\": {           \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\": {             \"Shards\": {               \"0\": {                 \"NodeId\": \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\",                 \"State\": \"Cancelled\",                 \"VerificationResult\": {},                 \"PublishedResults\": {}               }             }           },           \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\": {             \"Shards\": {               \"0\": {                 \"NodeId\": \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\",                 \"State\": \"Completed\",                 \"Status\": \"Got results proposal of length: 0\",                 \"VerificationResult\": {                   \"Complete\": true,                   \"Result\": true                 },                 \"PublishedResults\": {                   \"StorageSource\": \"IPFS\",                   \"Name\": \"job-92d5d4ee-3765-4f78-8353-623f5f26df08-shard-0-host-QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\",                   \"CID\": \"QmWUXBndMuq2G6B6ndQCmkRHjZ6CvyJ8qLxXBG3YsSFzQG\"                 },                 \"RunOutput\": {                   \"stdout\": \"\",                   \"stdouttruncated\": false,                   \"stderr\": \"\",                   \"stderrtruncated\": false,                   \"exitCode\": 0,                   \"runnerError\": \"\"                 }               }             }           }         }       }     }   ] } ```
         * @summary Simply lists jobs.
         * @param {PublicapiListRequest} body Set &#x60;return_all&#x60; to &#x60;true&#x60; to return all jobs on the network (may degrade performance, use with care!).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pkgpublicapiList(body: PublicapiListRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling pkgpublicapiList.');
            }
            const localVarPath = `/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PublicapiListRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Events (e.g. Created, Bid, BidAccepted, ..., ResultsAccepted, ResultsPublished) are useful to track the progress of a job.  Example response (truncated): ```json {   \"events\": [     {       \"APIVersion\": \"V1beta1\",       \"JobID\": \"9304c616-291f-41ad-b862-54e133c0149e\",       \"ClientID\": \"ac13188e93c97a9c2e7cf8e86c7313156a73436036f30da1ececc2ce79f9ea51\",       \"SourceNodeID\": \"QmXaXu9N5GNetatsvwnTfQqNtSeKAD6uCmarbh3LMRYAcF\",       \"EventName\": \"Created\",       \"Spec\": {         \"Engine\": \"Docker\",         \"Verifier\": \"Noop\",         \"Publisher\": \"Estuary\",         \"Docker\": {           \"Image\": \"ubuntu\",           \"Entrypoint\": [             \"date\"           ]         },         \"Language\": {           \"JobContext\": {}         },         \"Wasm\": {},         \"Resources\": {           \"GPU\": \"\"         },         \"Timeout\": 1800,         \"outputs\": [           {             \"StorageSource\": \"IPFS\",             \"Name\": \"outputs\",             \"path\": \"/outputs\"           }         ],         \"Sharding\": {           \"BatchSize\": 1,           \"GlobPatternBasePath\": \"/inputs\"         }       },       \"JobExecutionPlan\": {         \"ShardsTotal\": 1       },       \"Deal\": {         \"Concurrency\": 1       },       \"VerificationResult\": {},       \"PublishedResult\": {},       \"EventTime\": \"2022-11-17T13:32:55.331375351Z\",       \"SenderPublicKey\": \"...\"     },     ...     {       \"JobID\": \"9304c616-291f-41ad-b862-54e133c0149e\",       \"SourceNodeID\": \"QmXaXu9N5GNetatsvwnTfQqNtSeKAD6uCmarbh3LMRYAcF\",       \"TargetNodeID\": \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",       \"EventName\": \"ResultsAccepted\",       \"Spec\": {         \"Docker\": {},         \"Language\": {           \"JobContext\": {}         },         \"Wasm\": {},         \"Resources\": {           \"GPU\": \"\"         },         \"Sharding\": {}       },       \"JobExecutionPlan\": {},       \"Deal\": {},       \"VerificationResult\": {         \"Complete\": true,         \"Result\": true       },       \"PublishedResult\": {},       \"EventTime\": \"2022-11-17T13:32:55.707825569Z\",       \"SenderPublicKey\": \"...\"     },     {       \"JobID\": \"9304c616-291f-41ad-b862-54e133c0149e\",       \"SourceNodeID\": \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",       \"EventName\": \"ResultsPublished\",       \"Spec\": {         \"Docker\": {},         \"Language\": {           \"JobContext\": {}         },         \"Wasm\": {},         \"Resources\": {           \"GPU\": \"\"         },         \"Sharding\": {}       },       \"JobExecutionPlan\": {},       \"Deal\": {},       \"VerificationResult\": {},       \"PublishedResult\": {         \"StorageSource\": \"IPFS\",         \"Name\": \"job-9304c616-291f-41ad-b862-54e133c0149e-shard-0-host-QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",         \"CID\": \"QmTVmC7JBD2ES2qGPqBNVWnX1KeEPNrPGb7rJ8cpFgtefe\"       },       \"EventTime\": \"2022-11-17T13:32:55.756658941Z\",       \"SenderPublicKey\": \"...\"     }   ] } ```
         * @summary Returns the events related to the job-id passed in the body payload. Useful for troubleshooting.
         * @param {PublicapiEventsRequest} body Request must specify a &#x60;client_id&#x60;. To retrieve your &#x60;client_id&#x60;, you can do the following: (1) submit a dummy job to Bacalhau (or use one you created before), (2) run &#x60;bacalhau describe &lt;job-id&gt;&#x60; and fetch the &#x60;ClientID&#x60; field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pkgpublicapievents(body: PublicapiEventsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling pkgpublicapievents.');
            }
            const localVarPath = `/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PublicapiEventsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Local events (e.g. Selected, BidAccepted, Verified) are useful to track the progress of a job.
         * @summary Returns the node's local events related to the job-id passed in the body payload. Useful for troubleshooting.
         * @param {PublicapiLocalEventsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pkgpublicapilocalEvents(body: PublicapiLocalEventsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling pkgpublicapilocalEvents.');
            }
            const localVarPath = `/local_events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PublicapiLocalEventsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Example response:  ```json {   \"results\": [     {       \"NodeID\": \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",       \"Data\": {         \"StorageSource\": \"IPFS\",         \"Name\": \"job-9304c616-291f-41ad-b862-54e133c0149e-shard-0-host-QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",         \"CID\": \"QmTVmC7JBD2ES2qGPqBNVWnX1KeEPNrPGb7rJ8cpFgtefe\"       }     }   ] } ```
         * @summary Returns the results of the job-id specified in the body payload.
         * @param {PublicapiStateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pkgpublicapiresults(body: PublicapiStateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling pkgpublicapiresults.');
            }
            const localVarPath = `/results`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PublicapiStateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Example response:  ```json {   \"state\": {     \"Nodes\": {       \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\": {         \"Shards\": {           \"0\": {             \"NodeId\": \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\",             \"State\": \"Cancelled\",             \"VerificationResult\": {},             \"PublishedResults\": {}           }         }       },       \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\": {         \"Shards\": {           \"0\": {             \"NodeId\": \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\",             \"State\": \"Cancelled\",             \"VerificationResult\": {},             \"PublishedResults\": {}           }         }       },       \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\": {         \"Shards\": {           \"0\": {             \"NodeId\": \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",             \"State\": \"Completed\",             \"Status\": \"Got results proposal of length: 0\",             \"VerificationResult\": {               \"Complete\": true,               \"Result\": true             },             \"PublishedResults\": {               \"StorageSource\": \"IPFS\",               \"Name\": \"job-9304c616-291f-41ad-b862-54e133c0149e-shard-0-host-QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",               \"CID\": \"QmTVmC7JBD2ES2qGPqBNVWnX1KeEPNrPGb7rJ8cpFgtefe\"             },             \"RunOutput\": {               \"stdout\": \"Thu Nov 17 13:32:55 UTC 2022\\n\",               \"stdouttruncated\": false,               \"stderr\": \"\",               \"stderrtruncated\": false,               \"exitCode\": 0,               \"runnerError\": \"\"             }           }         }       }     }   } } ```
         * @summary Returns the state of the job-id specified in the body payload.
         * @param {PublicapiStateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pkgpublicapistates(body: PublicapiStateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling pkgpublicapistates.');
            }
            const localVarPath = `/states`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PublicapiStateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobApi - functional programming interface
 * @export
 */
export const JobApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Description:  * `client_public_key`: The base64-encoded public key of the client. * `signature`: A base64-encoded signature of the `data` attribute, signed by the client. * `data`     * `ClientID`: Request must specify a `ClientID`. To retrieve your `ClientID`, you can do the following: (1) submit a dummy job to Bacalhau (or use one you created before), (2) run `bacalhau describe <job-id>` and fetch the `ClientID` field.     * `Job`: see example below.  Example request ```json {  \"data\": {   \"ClientID\": \"ac13188e93c97a9c2e7cf8e86c7313156a73436036f30da1ececc2ce79f9ea51\",   \"Job\": {    \"APIVersion\": \"V1beta1\",    \"Spec\": {     \"Engine\": \"Docker\",     \"Verifier\": \"Noop\",     \"Publisher\": \"Estuary\",     \"Docker\": {      \"Image\": \"ubuntu\",      \"Entrypoint\": [       \"date\"      ]     },     \"Timeout\": 1800,     \"outputs\": [      {       \"StorageSource\": \"IPFS\",       \"Name\": \"outputs\",       \"path\": \"/outputs\"      }     ],     \"Sharding\": {      \"BatchSize\": 1,      \"GlobPatternBasePath\": \"/inputs\"     }    },    \"Deal\": {     \"Concurrency\": 1    }   }  },  \"signature\": \"...\",  \"client_public_key\": \"...\" } ```
         * @summary Submits a new job to the network.
         * @param {PublicapiSubmitRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pkgapiServerSubmit(body: PublicapiSubmitRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PublicapiSubmitResponse> {
            const localVarFetchArgs = JobApiFetchParamCreator(configuration).pkgapiServerSubmit(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the first (sorted) #`max_jobs` jobs that belong to the `client_id` passed in the body payload (by default). If `return_all` is set to true, it returns all jobs on the Bacalhau network.  If `id` is set, it returns only the job with that ID.  Example response: ```json {   \"jobs\": [     {       \"APIVersion\": \"V1beta1\",       \"ID\": \"9304c616-291f-41ad-b862-54e133c0149e\",       \"RequesterNodeID\": \"QmXaXu9N5GNetatsvwnTfQqNtSeKAD6uCmarbh3LMRYAcF\",       \"RequesterPublicKey\": \"...\",       \"ClientID\": \"ac13188e93c97a9c2e7cf8e86c7313156a73436036f30da1ececc2ce79f9ea51\",       \"Spec\": {         \"Engine\": \"Docker\",         \"Verifier\": \"Noop\",         \"Publisher\": \"Estuary\",         \"Docker\": {           \"Image\": \"ubuntu\",           \"Entrypoint\": [             \"date\"           ]         },         \"Language\": {           \"JobContext\": {}         },         \"Wasm\": {},         \"Resources\": {           \"GPU\": \"\"         },         \"Timeout\": 1800,         \"outputs\": [           {             \"StorageSource\": \"IPFS\",             \"Name\": \"outputs\",             \"path\": \"/outputs\"           }         ],         \"Sharding\": {           \"BatchSize\": 1,           \"GlobPatternBasePath\": \"/inputs\"         }       },       \"Deal\": {         \"Concurrency\": 1       },       \"ExecutionPlan\": {         \"ShardsTotal\": 1       },       \"CreatedAt\": \"2022-11-17T13:32:55.33837275Z\",       \"JobState\": {         \"Nodes\": {           \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\": {             \"Shards\": {               \"0\": {                 \"NodeId\": \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\",                 \"State\": \"Cancelled\",                 \"VerificationResult\": {},                 \"PublishedResults\": {}               }             }           },           \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\": {             \"Shards\": {               \"0\": {                 \"NodeId\": \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\",                 \"State\": \"Cancelled\",                 \"VerificationResult\": {},                 \"PublishedResults\": {}               }             }           },           \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\": {             \"Shards\": {               \"0\": {                 \"NodeId\": \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",                 \"State\": \"Completed\",                 \"Status\": \"Got results proposal of length: 0\",                 \"VerificationResult\": {                   \"Complete\": true,                   \"Result\": true                 },                 \"PublishedResults\": {                   \"StorageSource\": \"IPFS\",                   \"Name\": \"job-9304c616-291f-41ad-b862-54e133c0149e-shard-0-host-QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",                   \"CID\": \"QmTVmC7JBD2ES2qGPqBNVWnX1KeEPNrPGb7rJ8cpFgtefe\"                 },                 \"RunOutput\": {                   \"stdout\": \"Thu Nov 17 13:32:55 UTC 2022\\n\",                   \"stdouttruncated\": false,                   \"stderr\": \"\",                   \"stderrtruncated\": false,                   \"exitCode\": 0,                   \"runnerError\": \"\"                 }               }             }           }         }       }     },     {       \"APIVersion\": \"V1beta1\",       \"ID\": \"92d5d4ee-3765-4f78-8353-623f5f26df08\",       \"RequesterNodeID\": \"QmXaXu9N5GNetatsvwnTfQqNtSeKAD6uCmarbh3LMRYAcF\",       \"RequesterPublicKey\": \"...\",       \"ClientID\": \"ac13188e93c97a9c2e7cf8e86c7313156a73436036f30da1ececc2ce79f9ea51\",       \"Spec\": {         \"Engine\": \"Docker\",         \"Verifier\": \"Noop\",         \"Publisher\": \"Estuary\",         \"Docker\": {           \"Image\": \"ubuntu\",           \"Entrypoint\": [             \"sleep\",             \"4\"           ]         },         \"Language\": {           \"JobContext\": {}         },         \"Wasm\": {},         \"Resources\": {           \"GPU\": \"\"         },         \"Timeout\": 1800,         \"outputs\": [           {             \"StorageSource\": \"IPFS\",             \"Name\": \"outputs\",             \"path\": \"/outputs\"           }         ],         \"Sharding\": {           \"BatchSize\": 1,           \"GlobPatternBasePath\": \"/inputs\"         }       },       \"Deal\": {         \"Concurrency\": 1       },       \"ExecutionPlan\": {         \"ShardsTotal\": 1       },       \"CreatedAt\": \"2022-11-17T13:29:01.871140291Z\",       \"JobState\": {         \"Nodes\": {           \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\": {             \"Shards\": {               \"0\": {                 \"NodeId\": \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\",                 \"State\": \"Cancelled\",                 \"VerificationResult\": {},                 \"PublishedResults\": {}               }             }           },           \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\": {             \"Shards\": {               \"0\": {                 \"NodeId\": \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\",                 \"State\": \"Completed\",                 \"Status\": \"Got results proposal of length: 0\",                 \"VerificationResult\": {                   \"Complete\": true,                   \"Result\": true                 },                 \"PublishedResults\": {                   \"StorageSource\": \"IPFS\",                   \"Name\": \"job-92d5d4ee-3765-4f78-8353-623f5f26df08-shard-0-host-QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\",                   \"CID\": \"QmWUXBndMuq2G6B6ndQCmkRHjZ6CvyJ8qLxXBG3YsSFzQG\"                 },                 \"RunOutput\": {                   \"stdout\": \"\",                   \"stdouttruncated\": false,                   \"stderr\": \"\",                   \"stderrtruncated\": false,                   \"exitCode\": 0,                   \"runnerError\": \"\"                 }               }             }           }         }       }     }   ] } ```
         * @summary Simply lists jobs.
         * @param {PublicapiListRequest} body Set &#x60;return_all&#x60; to &#x60;true&#x60; to return all jobs on the network (may degrade performance, use with care!).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pkgpublicapiList(body: PublicapiListRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PublicapiListResponse> {
            const localVarFetchArgs = JobApiFetchParamCreator(configuration).pkgpublicapiList(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Events (e.g. Created, Bid, BidAccepted, ..., ResultsAccepted, ResultsPublished) are useful to track the progress of a job.  Example response (truncated): ```json {   \"events\": [     {       \"APIVersion\": \"V1beta1\",       \"JobID\": \"9304c616-291f-41ad-b862-54e133c0149e\",       \"ClientID\": \"ac13188e93c97a9c2e7cf8e86c7313156a73436036f30da1ececc2ce79f9ea51\",       \"SourceNodeID\": \"QmXaXu9N5GNetatsvwnTfQqNtSeKAD6uCmarbh3LMRYAcF\",       \"EventName\": \"Created\",       \"Spec\": {         \"Engine\": \"Docker\",         \"Verifier\": \"Noop\",         \"Publisher\": \"Estuary\",         \"Docker\": {           \"Image\": \"ubuntu\",           \"Entrypoint\": [             \"date\"           ]         },         \"Language\": {           \"JobContext\": {}         },         \"Wasm\": {},         \"Resources\": {           \"GPU\": \"\"         },         \"Timeout\": 1800,         \"outputs\": [           {             \"StorageSource\": \"IPFS\",             \"Name\": \"outputs\",             \"path\": \"/outputs\"           }         ],         \"Sharding\": {           \"BatchSize\": 1,           \"GlobPatternBasePath\": \"/inputs\"         }       },       \"JobExecutionPlan\": {         \"ShardsTotal\": 1       },       \"Deal\": {         \"Concurrency\": 1       },       \"VerificationResult\": {},       \"PublishedResult\": {},       \"EventTime\": \"2022-11-17T13:32:55.331375351Z\",       \"SenderPublicKey\": \"...\"     },     ...     {       \"JobID\": \"9304c616-291f-41ad-b862-54e133c0149e\",       \"SourceNodeID\": \"QmXaXu9N5GNetatsvwnTfQqNtSeKAD6uCmarbh3LMRYAcF\",       \"TargetNodeID\": \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",       \"EventName\": \"ResultsAccepted\",       \"Spec\": {         \"Docker\": {},         \"Language\": {           \"JobContext\": {}         },         \"Wasm\": {},         \"Resources\": {           \"GPU\": \"\"         },         \"Sharding\": {}       },       \"JobExecutionPlan\": {},       \"Deal\": {},       \"VerificationResult\": {         \"Complete\": true,         \"Result\": true       },       \"PublishedResult\": {},       \"EventTime\": \"2022-11-17T13:32:55.707825569Z\",       \"SenderPublicKey\": \"...\"     },     {       \"JobID\": \"9304c616-291f-41ad-b862-54e133c0149e\",       \"SourceNodeID\": \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",       \"EventName\": \"ResultsPublished\",       \"Spec\": {         \"Docker\": {},         \"Language\": {           \"JobContext\": {}         },         \"Wasm\": {},         \"Resources\": {           \"GPU\": \"\"         },         \"Sharding\": {}       },       \"JobExecutionPlan\": {},       \"Deal\": {},       \"VerificationResult\": {},       \"PublishedResult\": {         \"StorageSource\": \"IPFS\",         \"Name\": \"job-9304c616-291f-41ad-b862-54e133c0149e-shard-0-host-QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",         \"CID\": \"QmTVmC7JBD2ES2qGPqBNVWnX1KeEPNrPGb7rJ8cpFgtefe\"       },       \"EventTime\": \"2022-11-17T13:32:55.756658941Z\",       \"SenderPublicKey\": \"...\"     }   ] } ```
         * @summary Returns the events related to the job-id passed in the body payload. Useful for troubleshooting.
         * @param {PublicapiEventsRequest} body Request must specify a &#x60;client_id&#x60;. To retrieve your &#x60;client_id&#x60;, you can do the following: (1) submit a dummy job to Bacalhau (or use one you created before), (2) run &#x60;bacalhau describe &lt;job-id&gt;&#x60; and fetch the &#x60;ClientID&#x60; field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pkgpublicapievents(body: PublicapiEventsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PublicapiEventsResponse> {
            const localVarFetchArgs = JobApiFetchParamCreator(configuration).pkgpublicapievents(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Local events (e.g. Selected, BidAccepted, Verified) are useful to track the progress of a job.
         * @summary Returns the node's local events related to the job-id passed in the body payload. Useful for troubleshooting.
         * @param {PublicapiLocalEventsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pkgpublicapilocalEvents(body: PublicapiLocalEventsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PublicapiLocalEventsResponse> {
            const localVarFetchArgs = JobApiFetchParamCreator(configuration).pkgpublicapilocalEvents(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Example response:  ```json {   \"results\": [     {       \"NodeID\": \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",       \"Data\": {         \"StorageSource\": \"IPFS\",         \"Name\": \"job-9304c616-291f-41ad-b862-54e133c0149e-shard-0-host-QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",         \"CID\": \"QmTVmC7JBD2ES2qGPqBNVWnX1KeEPNrPGb7rJ8cpFgtefe\"       }     }   ] } ```
         * @summary Returns the results of the job-id specified in the body payload.
         * @param {PublicapiStateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pkgpublicapiresults(body: PublicapiStateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PublicapiResultsResponse> {
            const localVarFetchArgs = JobApiFetchParamCreator(configuration).pkgpublicapiresults(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Example response:  ```json {   \"state\": {     \"Nodes\": {       \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\": {         \"Shards\": {           \"0\": {             \"NodeId\": \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\",             \"State\": \"Cancelled\",             \"VerificationResult\": {},             \"PublishedResults\": {}           }         }       },       \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\": {         \"Shards\": {           \"0\": {             \"NodeId\": \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\",             \"State\": \"Cancelled\",             \"VerificationResult\": {},             \"PublishedResults\": {}           }         }       },       \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\": {         \"Shards\": {           \"0\": {             \"NodeId\": \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",             \"State\": \"Completed\",             \"Status\": \"Got results proposal of length: 0\",             \"VerificationResult\": {               \"Complete\": true,               \"Result\": true             },             \"PublishedResults\": {               \"StorageSource\": \"IPFS\",               \"Name\": \"job-9304c616-291f-41ad-b862-54e133c0149e-shard-0-host-QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",               \"CID\": \"QmTVmC7JBD2ES2qGPqBNVWnX1KeEPNrPGb7rJ8cpFgtefe\"             },             \"RunOutput\": {               \"stdout\": \"Thu Nov 17 13:32:55 UTC 2022\\n\",               \"stdouttruncated\": false,               \"stderr\": \"\",               \"stderrtruncated\": false,               \"exitCode\": 0,               \"runnerError\": \"\"             }           }         }       }     }   } } ```
         * @summary Returns the state of the job-id specified in the body payload.
         * @param {PublicapiStateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pkgpublicapistates(body: PublicapiStateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PublicapiStateResponse> {
            const localVarFetchArgs = JobApiFetchParamCreator(configuration).pkgpublicapistates(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * JobApi - factory interface
 * @export
 */
export const JobApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Description:  * `client_public_key`: The base64-encoded public key of the client. * `signature`: A base64-encoded signature of the `data` attribute, signed by the client. * `data`     * `ClientID`: Request must specify a `ClientID`. To retrieve your `ClientID`, you can do the following: (1) submit a dummy job to Bacalhau (or use one you created before), (2) run `bacalhau describe <job-id>` and fetch the `ClientID` field.     * `Job`: see example below.  Example request ```json {  \"data\": {   \"ClientID\": \"ac13188e93c97a9c2e7cf8e86c7313156a73436036f30da1ececc2ce79f9ea51\",   \"Job\": {    \"APIVersion\": \"V1beta1\",    \"Spec\": {     \"Engine\": \"Docker\",     \"Verifier\": \"Noop\",     \"Publisher\": \"Estuary\",     \"Docker\": {      \"Image\": \"ubuntu\",      \"Entrypoint\": [       \"date\"      ]     },     \"Timeout\": 1800,     \"outputs\": [      {       \"StorageSource\": \"IPFS\",       \"Name\": \"outputs\",       \"path\": \"/outputs\"      }     ],     \"Sharding\": {      \"BatchSize\": 1,      \"GlobPatternBasePath\": \"/inputs\"     }    },    \"Deal\": {     \"Concurrency\": 1    }   }  },  \"signature\": \"...\",  \"client_public_key\": \"...\" } ```
         * @summary Submits a new job to the network.
         * @param {PublicapiSubmitRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pkgapiServerSubmit(body: PublicapiSubmitRequest, options?: any) {
            return JobApiFp(configuration).pkgapiServerSubmit(body, options)(fetch, basePath);
        },
        /**
         * Returns the first (sorted) #`max_jobs` jobs that belong to the `client_id` passed in the body payload (by default). If `return_all` is set to true, it returns all jobs on the Bacalhau network.  If `id` is set, it returns only the job with that ID.  Example response: ```json {   \"jobs\": [     {       \"APIVersion\": \"V1beta1\",       \"ID\": \"9304c616-291f-41ad-b862-54e133c0149e\",       \"RequesterNodeID\": \"QmXaXu9N5GNetatsvwnTfQqNtSeKAD6uCmarbh3LMRYAcF\",       \"RequesterPublicKey\": \"...\",       \"ClientID\": \"ac13188e93c97a9c2e7cf8e86c7313156a73436036f30da1ececc2ce79f9ea51\",       \"Spec\": {         \"Engine\": \"Docker\",         \"Verifier\": \"Noop\",         \"Publisher\": \"Estuary\",         \"Docker\": {           \"Image\": \"ubuntu\",           \"Entrypoint\": [             \"date\"           ]         },         \"Language\": {           \"JobContext\": {}         },         \"Wasm\": {},         \"Resources\": {           \"GPU\": \"\"         },         \"Timeout\": 1800,         \"outputs\": [           {             \"StorageSource\": \"IPFS\",             \"Name\": \"outputs\",             \"path\": \"/outputs\"           }         ],         \"Sharding\": {           \"BatchSize\": 1,           \"GlobPatternBasePath\": \"/inputs\"         }       },       \"Deal\": {         \"Concurrency\": 1       },       \"ExecutionPlan\": {         \"ShardsTotal\": 1       },       \"CreatedAt\": \"2022-11-17T13:32:55.33837275Z\",       \"JobState\": {         \"Nodes\": {           \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\": {             \"Shards\": {               \"0\": {                 \"NodeId\": \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\",                 \"State\": \"Cancelled\",                 \"VerificationResult\": {},                 \"PublishedResults\": {}               }             }           },           \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\": {             \"Shards\": {               \"0\": {                 \"NodeId\": \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\",                 \"State\": \"Cancelled\",                 \"VerificationResult\": {},                 \"PublishedResults\": {}               }             }           },           \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\": {             \"Shards\": {               \"0\": {                 \"NodeId\": \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",                 \"State\": \"Completed\",                 \"Status\": \"Got results proposal of length: 0\",                 \"VerificationResult\": {                   \"Complete\": true,                   \"Result\": true                 },                 \"PublishedResults\": {                   \"StorageSource\": \"IPFS\",                   \"Name\": \"job-9304c616-291f-41ad-b862-54e133c0149e-shard-0-host-QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",                   \"CID\": \"QmTVmC7JBD2ES2qGPqBNVWnX1KeEPNrPGb7rJ8cpFgtefe\"                 },                 \"RunOutput\": {                   \"stdout\": \"Thu Nov 17 13:32:55 UTC 2022\\n\",                   \"stdouttruncated\": false,                   \"stderr\": \"\",                   \"stderrtruncated\": false,                   \"exitCode\": 0,                   \"runnerError\": \"\"                 }               }             }           }         }       }     },     {       \"APIVersion\": \"V1beta1\",       \"ID\": \"92d5d4ee-3765-4f78-8353-623f5f26df08\",       \"RequesterNodeID\": \"QmXaXu9N5GNetatsvwnTfQqNtSeKAD6uCmarbh3LMRYAcF\",       \"RequesterPublicKey\": \"...\",       \"ClientID\": \"ac13188e93c97a9c2e7cf8e86c7313156a73436036f30da1ececc2ce79f9ea51\",       \"Spec\": {         \"Engine\": \"Docker\",         \"Verifier\": \"Noop\",         \"Publisher\": \"Estuary\",         \"Docker\": {           \"Image\": \"ubuntu\",           \"Entrypoint\": [             \"sleep\",             \"4\"           ]         },         \"Language\": {           \"JobContext\": {}         },         \"Wasm\": {},         \"Resources\": {           \"GPU\": \"\"         },         \"Timeout\": 1800,         \"outputs\": [           {             \"StorageSource\": \"IPFS\",             \"Name\": \"outputs\",             \"path\": \"/outputs\"           }         ],         \"Sharding\": {           \"BatchSize\": 1,           \"GlobPatternBasePath\": \"/inputs\"         }       },       \"Deal\": {         \"Concurrency\": 1       },       \"ExecutionPlan\": {         \"ShardsTotal\": 1       },       \"CreatedAt\": \"2022-11-17T13:29:01.871140291Z\",       \"JobState\": {         \"Nodes\": {           \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\": {             \"Shards\": {               \"0\": {                 \"NodeId\": \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\",                 \"State\": \"Cancelled\",                 \"VerificationResult\": {},                 \"PublishedResults\": {}               }             }           },           \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\": {             \"Shards\": {               \"0\": {                 \"NodeId\": \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\",                 \"State\": \"Completed\",                 \"Status\": \"Got results proposal of length: 0\",                 \"VerificationResult\": {                   \"Complete\": true,                   \"Result\": true                 },                 \"PublishedResults\": {                   \"StorageSource\": \"IPFS\",                   \"Name\": \"job-92d5d4ee-3765-4f78-8353-623f5f26df08-shard-0-host-QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\",                   \"CID\": \"QmWUXBndMuq2G6B6ndQCmkRHjZ6CvyJ8qLxXBG3YsSFzQG\"                 },                 \"RunOutput\": {                   \"stdout\": \"\",                   \"stdouttruncated\": false,                   \"stderr\": \"\",                   \"stderrtruncated\": false,                   \"exitCode\": 0,                   \"runnerError\": \"\"                 }               }             }           }         }       }     }   ] } ```
         * @summary Simply lists jobs.
         * @param {PublicapiListRequest} body Set &#x60;return_all&#x60; to &#x60;true&#x60; to return all jobs on the network (may degrade performance, use with care!).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pkgpublicapiList(body: PublicapiListRequest, options?: any) {
            return JobApiFp(configuration).pkgpublicapiList(body, options)(fetch, basePath);
        },
        /**
         * Events (e.g. Created, Bid, BidAccepted, ..., ResultsAccepted, ResultsPublished) are useful to track the progress of a job.  Example response (truncated): ```json {   \"events\": [     {       \"APIVersion\": \"V1beta1\",       \"JobID\": \"9304c616-291f-41ad-b862-54e133c0149e\",       \"ClientID\": \"ac13188e93c97a9c2e7cf8e86c7313156a73436036f30da1ececc2ce79f9ea51\",       \"SourceNodeID\": \"QmXaXu9N5GNetatsvwnTfQqNtSeKAD6uCmarbh3LMRYAcF\",       \"EventName\": \"Created\",       \"Spec\": {         \"Engine\": \"Docker\",         \"Verifier\": \"Noop\",         \"Publisher\": \"Estuary\",         \"Docker\": {           \"Image\": \"ubuntu\",           \"Entrypoint\": [             \"date\"           ]         },         \"Language\": {           \"JobContext\": {}         },         \"Wasm\": {},         \"Resources\": {           \"GPU\": \"\"         },         \"Timeout\": 1800,         \"outputs\": [           {             \"StorageSource\": \"IPFS\",             \"Name\": \"outputs\",             \"path\": \"/outputs\"           }         ],         \"Sharding\": {           \"BatchSize\": 1,           \"GlobPatternBasePath\": \"/inputs\"         }       },       \"JobExecutionPlan\": {         \"ShardsTotal\": 1       },       \"Deal\": {         \"Concurrency\": 1       },       \"VerificationResult\": {},       \"PublishedResult\": {},       \"EventTime\": \"2022-11-17T13:32:55.331375351Z\",       \"SenderPublicKey\": \"...\"     },     ...     {       \"JobID\": \"9304c616-291f-41ad-b862-54e133c0149e\",       \"SourceNodeID\": \"QmXaXu9N5GNetatsvwnTfQqNtSeKAD6uCmarbh3LMRYAcF\",       \"TargetNodeID\": \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",       \"EventName\": \"ResultsAccepted\",       \"Spec\": {         \"Docker\": {},         \"Language\": {           \"JobContext\": {}         },         \"Wasm\": {},         \"Resources\": {           \"GPU\": \"\"         },         \"Sharding\": {}       },       \"JobExecutionPlan\": {},       \"Deal\": {},       \"VerificationResult\": {         \"Complete\": true,         \"Result\": true       },       \"PublishedResult\": {},       \"EventTime\": \"2022-11-17T13:32:55.707825569Z\",       \"SenderPublicKey\": \"...\"     },     {       \"JobID\": \"9304c616-291f-41ad-b862-54e133c0149e\",       \"SourceNodeID\": \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",       \"EventName\": \"ResultsPublished\",       \"Spec\": {         \"Docker\": {},         \"Language\": {           \"JobContext\": {}         },         \"Wasm\": {},         \"Resources\": {           \"GPU\": \"\"         },         \"Sharding\": {}       },       \"JobExecutionPlan\": {},       \"Deal\": {},       \"VerificationResult\": {},       \"PublishedResult\": {         \"StorageSource\": \"IPFS\",         \"Name\": \"job-9304c616-291f-41ad-b862-54e133c0149e-shard-0-host-QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",         \"CID\": \"QmTVmC7JBD2ES2qGPqBNVWnX1KeEPNrPGb7rJ8cpFgtefe\"       },       \"EventTime\": \"2022-11-17T13:32:55.756658941Z\",       \"SenderPublicKey\": \"...\"     }   ] } ```
         * @summary Returns the events related to the job-id passed in the body payload. Useful for troubleshooting.
         * @param {PublicapiEventsRequest} body Request must specify a &#x60;client_id&#x60;. To retrieve your &#x60;client_id&#x60;, you can do the following: (1) submit a dummy job to Bacalhau (or use one you created before), (2) run &#x60;bacalhau describe &lt;job-id&gt;&#x60; and fetch the &#x60;ClientID&#x60; field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pkgpublicapievents(body: PublicapiEventsRequest, options?: any) {
            return JobApiFp(configuration).pkgpublicapievents(body, options)(fetch, basePath);
        },
        /**
         * Local events (e.g. Selected, BidAccepted, Verified) are useful to track the progress of a job.
         * @summary Returns the node's local events related to the job-id passed in the body payload. Useful for troubleshooting.
         * @param {PublicapiLocalEventsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pkgpublicapilocalEvents(body: PublicapiLocalEventsRequest, options?: any) {
            return JobApiFp(configuration).pkgpublicapilocalEvents(body, options)(fetch, basePath);
        },
        /**
         * Example response:  ```json {   \"results\": [     {       \"NodeID\": \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",       \"Data\": {         \"StorageSource\": \"IPFS\",         \"Name\": \"job-9304c616-291f-41ad-b862-54e133c0149e-shard-0-host-QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",         \"CID\": \"QmTVmC7JBD2ES2qGPqBNVWnX1KeEPNrPGb7rJ8cpFgtefe\"       }     }   ] } ```
         * @summary Returns the results of the job-id specified in the body payload.
         * @param {PublicapiStateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pkgpublicapiresults(body: PublicapiStateRequest, options?: any) {
            return JobApiFp(configuration).pkgpublicapiresults(body, options)(fetch, basePath);
        },
        /**
         * Example response:  ```json {   \"state\": {     \"Nodes\": {       \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\": {         \"Shards\": {           \"0\": {             \"NodeId\": \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\",             \"State\": \"Cancelled\",             \"VerificationResult\": {},             \"PublishedResults\": {}           }         }       },       \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\": {         \"Shards\": {           \"0\": {             \"NodeId\": \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\",             \"State\": \"Cancelled\",             \"VerificationResult\": {},             \"PublishedResults\": {}           }         }       },       \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\": {         \"Shards\": {           \"0\": {             \"NodeId\": \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",             \"State\": \"Completed\",             \"Status\": \"Got results proposal of length: 0\",             \"VerificationResult\": {               \"Complete\": true,               \"Result\": true             },             \"PublishedResults\": {               \"StorageSource\": \"IPFS\",               \"Name\": \"job-9304c616-291f-41ad-b862-54e133c0149e-shard-0-host-QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",               \"CID\": \"QmTVmC7JBD2ES2qGPqBNVWnX1KeEPNrPGb7rJ8cpFgtefe\"             },             \"RunOutput\": {               \"stdout\": \"Thu Nov 17 13:32:55 UTC 2022\\n\",               \"stdouttruncated\": false,               \"stderr\": \"\",               \"stderrtruncated\": false,               \"exitCode\": 0,               \"runnerError\": \"\"             }           }         }       }     }   } } ```
         * @summary Returns the state of the job-id specified in the body payload.
         * @param {PublicapiStateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pkgpublicapistates(body: PublicapiStateRequest, options?: any) {
            return JobApiFp(configuration).pkgpublicapistates(body, options)(fetch, basePath);
        },
    };
};

/**
 * JobApi - object-oriented interface
 * @export
 * @class JobApi
 * @extends {BaseAPI}
 */
export class JobApi extends BaseAPI {
    /**
     * Description:  * `client_public_key`: The base64-encoded public key of the client. * `signature`: A base64-encoded signature of the `data` attribute, signed by the client. * `data`     * `ClientID`: Request must specify a `ClientID`. To retrieve your `ClientID`, you can do the following: (1) submit a dummy job to Bacalhau (or use one you created before), (2) run `bacalhau describe <job-id>` and fetch the `ClientID` field.     * `Job`: see example below.  Example request ```json {  \"data\": {   \"ClientID\": \"ac13188e93c97a9c2e7cf8e86c7313156a73436036f30da1ececc2ce79f9ea51\",   \"Job\": {    \"APIVersion\": \"V1beta1\",    \"Spec\": {     \"Engine\": \"Docker\",     \"Verifier\": \"Noop\",     \"Publisher\": \"Estuary\",     \"Docker\": {      \"Image\": \"ubuntu\",      \"Entrypoint\": [       \"date\"      ]     },     \"Timeout\": 1800,     \"outputs\": [      {       \"StorageSource\": \"IPFS\",       \"Name\": \"outputs\",       \"path\": \"/outputs\"      }     ],     \"Sharding\": {      \"BatchSize\": 1,      \"GlobPatternBasePath\": \"/inputs\"     }    },    \"Deal\": {     \"Concurrency\": 1    }   }  },  \"signature\": \"...\",  \"client_public_key\": \"...\" } ```
     * @summary Submits a new job to the network.
     * @param {PublicapiSubmitRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public pkgapiServerSubmit(body: PublicapiSubmitRequest, options?: any) {
        return JobApiFp(this.configuration).pkgapiServerSubmit(body, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the first (sorted) #`max_jobs` jobs that belong to the `client_id` passed in the body payload (by default). If `return_all` is set to true, it returns all jobs on the Bacalhau network.  If `id` is set, it returns only the job with that ID.  Example response: ```json {   \"jobs\": [     {       \"APIVersion\": \"V1beta1\",       \"ID\": \"9304c616-291f-41ad-b862-54e133c0149e\",       \"RequesterNodeID\": \"QmXaXu9N5GNetatsvwnTfQqNtSeKAD6uCmarbh3LMRYAcF\",       \"RequesterPublicKey\": \"...\",       \"ClientID\": \"ac13188e93c97a9c2e7cf8e86c7313156a73436036f30da1ececc2ce79f9ea51\",       \"Spec\": {         \"Engine\": \"Docker\",         \"Verifier\": \"Noop\",         \"Publisher\": \"Estuary\",         \"Docker\": {           \"Image\": \"ubuntu\",           \"Entrypoint\": [             \"date\"           ]         },         \"Language\": {           \"JobContext\": {}         },         \"Wasm\": {},         \"Resources\": {           \"GPU\": \"\"         },         \"Timeout\": 1800,         \"outputs\": [           {             \"StorageSource\": \"IPFS\",             \"Name\": \"outputs\",             \"path\": \"/outputs\"           }         ],         \"Sharding\": {           \"BatchSize\": 1,           \"GlobPatternBasePath\": \"/inputs\"         }       },       \"Deal\": {         \"Concurrency\": 1       },       \"ExecutionPlan\": {         \"ShardsTotal\": 1       },       \"CreatedAt\": \"2022-11-17T13:32:55.33837275Z\",       \"JobState\": {         \"Nodes\": {           \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\": {             \"Shards\": {               \"0\": {                 \"NodeId\": \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\",                 \"State\": \"Cancelled\",                 \"VerificationResult\": {},                 \"PublishedResults\": {}               }             }           },           \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\": {             \"Shards\": {               \"0\": {                 \"NodeId\": \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\",                 \"State\": \"Cancelled\",                 \"VerificationResult\": {},                 \"PublishedResults\": {}               }             }           },           \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\": {             \"Shards\": {               \"0\": {                 \"NodeId\": \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",                 \"State\": \"Completed\",                 \"Status\": \"Got results proposal of length: 0\",                 \"VerificationResult\": {                   \"Complete\": true,                   \"Result\": true                 },                 \"PublishedResults\": {                   \"StorageSource\": \"IPFS\",                   \"Name\": \"job-9304c616-291f-41ad-b862-54e133c0149e-shard-0-host-QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",                   \"CID\": \"QmTVmC7JBD2ES2qGPqBNVWnX1KeEPNrPGb7rJ8cpFgtefe\"                 },                 \"RunOutput\": {                   \"stdout\": \"Thu Nov 17 13:32:55 UTC 2022\\n\",                   \"stdouttruncated\": false,                   \"stderr\": \"\",                   \"stderrtruncated\": false,                   \"exitCode\": 0,                   \"runnerError\": \"\"                 }               }             }           }         }       }     },     {       \"APIVersion\": \"V1beta1\",       \"ID\": \"92d5d4ee-3765-4f78-8353-623f5f26df08\",       \"RequesterNodeID\": \"QmXaXu9N5GNetatsvwnTfQqNtSeKAD6uCmarbh3LMRYAcF\",       \"RequesterPublicKey\": \"...\",       \"ClientID\": \"ac13188e93c97a9c2e7cf8e86c7313156a73436036f30da1ececc2ce79f9ea51\",       \"Spec\": {         \"Engine\": \"Docker\",         \"Verifier\": \"Noop\",         \"Publisher\": \"Estuary\",         \"Docker\": {           \"Image\": \"ubuntu\",           \"Entrypoint\": [             \"sleep\",             \"4\"           ]         },         \"Language\": {           \"JobContext\": {}         },         \"Wasm\": {},         \"Resources\": {           \"GPU\": \"\"         },         \"Timeout\": 1800,         \"outputs\": [           {             \"StorageSource\": \"IPFS\",             \"Name\": \"outputs\",             \"path\": \"/outputs\"           }         ],         \"Sharding\": {           \"BatchSize\": 1,           \"GlobPatternBasePath\": \"/inputs\"         }       },       \"Deal\": {         \"Concurrency\": 1       },       \"ExecutionPlan\": {         \"ShardsTotal\": 1       },       \"CreatedAt\": \"2022-11-17T13:29:01.871140291Z\",       \"JobState\": {         \"Nodes\": {           \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\": {             \"Shards\": {               \"0\": {                 \"NodeId\": \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\",                 \"State\": \"Cancelled\",                 \"VerificationResult\": {},                 \"PublishedResults\": {}               }             }           },           \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\": {             \"Shards\": {               \"0\": {                 \"NodeId\": \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\",                 \"State\": \"Completed\",                 \"Status\": \"Got results proposal of length: 0\",                 \"VerificationResult\": {                   \"Complete\": true,                   \"Result\": true                 },                 \"PublishedResults\": {                   \"StorageSource\": \"IPFS\",                   \"Name\": \"job-92d5d4ee-3765-4f78-8353-623f5f26df08-shard-0-host-QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\",                   \"CID\": \"QmWUXBndMuq2G6B6ndQCmkRHjZ6CvyJ8qLxXBG3YsSFzQG\"                 },                 \"RunOutput\": {                   \"stdout\": \"\",                   \"stdouttruncated\": false,                   \"stderr\": \"\",                   \"stderrtruncated\": false,                   \"exitCode\": 0,                   \"runnerError\": \"\"                 }               }             }           }         }       }     }   ] } ```
     * @summary Simply lists jobs.
     * @param {PublicapiListRequest} body Set &#x60;return_all&#x60; to &#x60;true&#x60; to return all jobs on the network (may degrade performance, use with care!).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public pkgpublicapiList(body: PublicapiListRequest, options?: any) {
        return JobApiFp(this.configuration).pkgpublicapiList(body, options)(this.fetch, this.basePath);
    }

    /**
     * Events (e.g. Created, Bid, BidAccepted, ..., ResultsAccepted, ResultsPublished) are useful to track the progress of a job.  Example response (truncated): ```json {   \"events\": [     {       \"APIVersion\": \"V1beta1\",       \"JobID\": \"9304c616-291f-41ad-b862-54e133c0149e\",       \"ClientID\": \"ac13188e93c97a9c2e7cf8e86c7313156a73436036f30da1ececc2ce79f9ea51\",       \"SourceNodeID\": \"QmXaXu9N5GNetatsvwnTfQqNtSeKAD6uCmarbh3LMRYAcF\",       \"EventName\": \"Created\",       \"Spec\": {         \"Engine\": \"Docker\",         \"Verifier\": \"Noop\",         \"Publisher\": \"Estuary\",         \"Docker\": {           \"Image\": \"ubuntu\",           \"Entrypoint\": [             \"date\"           ]         },         \"Language\": {           \"JobContext\": {}         },         \"Wasm\": {},         \"Resources\": {           \"GPU\": \"\"         },         \"Timeout\": 1800,         \"outputs\": [           {             \"StorageSource\": \"IPFS\",             \"Name\": \"outputs\",             \"path\": \"/outputs\"           }         ],         \"Sharding\": {           \"BatchSize\": 1,           \"GlobPatternBasePath\": \"/inputs\"         }       },       \"JobExecutionPlan\": {         \"ShardsTotal\": 1       },       \"Deal\": {         \"Concurrency\": 1       },       \"VerificationResult\": {},       \"PublishedResult\": {},       \"EventTime\": \"2022-11-17T13:32:55.331375351Z\",       \"SenderPublicKey\": \"...\"     },     ...     {       \"JobID\": \"9304c616-291f-41ad-b862-54e133c0149e\",       \"SourceNodeID\": \"QmXaXu9N5GNetatsvwnTfQqNtSeKAD6uCmarbh3LMRYAcF\",       \"TargetNodeID\": \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",       \"EventName\": \"ResultsAccepted\",       \"Spec\": {         \"Docker\": {},         \"Language\": {           \"JobContext\": {}         },         \"Wasm\": {},         \"Resources\": {           \"GPU\": \"\"         },         \"Sharding\": {}       },       \"JobExecutionPlan\": {},       \"Deal\": {},       \"VerificationResult\": {         \"Complete\": true,         \"Result\": true       },       \"PublishedResult\": {},       \"EventTime\": \"2022-11-17T13:32:55.707825569Z\",       \"SenderPublicKey\": \"...\"     },     {       \"JobID\": \"9304c616-291f-41ad-b862-54e133c0149e\",       \"SourceNodeID\": \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",       \"EventName\": \"ResultsPublished\",       \"Spec\": {         \"Docker\": {},         \"Language\": {           \"JobContext\": {}         },         \"Wasm\": {},         \"Resources\": {           \"GPU\": \"\"         },         \"Sharding\": {}       },       \"JobExecutionPlan\": {},       \"Deal\": {},       \"VerificationResult\": {},       \"PublishedResult\": {         \"StorageSource\": \"IPFS\",         \"Name\": \"job-9304c616-291f-41ad-b862-54e133c0149e-shard-0-host-QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",         \"CID\": \"QmTVmC7JBD2ES2qGPqBNVWnX1KeEPNrPGb7rJ8cpFgtefe\"       },       \"EventTime\": \"2022-11-17T13:32:55.756658941Z\",       \"SenderPublicKey\": \"...\"     }   ] } ```
     * @summary Returns the events related to the job-id passed in the body payload. Useful for troubleshooting.
     * @param {PublicapiEventsRequest} body Request must specify a &#x60;client_id&#x60;. To retrieve your &#x60;client_id&#x60;, you can do the following: (1) submit a dummy job to Bacalhau (or use one you created before), (2) run &#x60;bacalhau describe &lt;job-id&gt;&#x60; and fetch the &#x60;ClientID&#x60; field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public pkgpublicapievents(body: PublicapiEventsRequest, options?: any) {
        return JobApiFp(this.configuration).pkgpublicapievents(body, options)(this.fetch, this.basePath);
    }

    /**
     * Local events (e.g. Selected, BidAccepted, Verified) are useful to track the progress of a job.
     * @summary Returns the node's local events related to the job-id passed in the body payload. Useful for troubleshooting.
     * @param {PublicapiLocalEventsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public pkgpublicapilocalEvents(body: PublicapiLocalEventsRequest, options?: any) {
        return JobApiFp(this.configuration).pkgpublicapilocalEvents(body, options)(this.fetch, this.basePath);
    }

    /**
     * Example response:  ```json {   \"results\": [     {       \"NodeID\": \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",       \"Data\": {         \"StorageSource\": \"IPFS\",         \"Name\": \"job-9304c616-291f-41ad-b862-54e133c0149e-shard-0-host-QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",         \"CID\": \"QmTVmC7JBD2ES2qGPqBNVWnX1KeEPNrPGb7rJ8cpFgtefe\"       }     }   ] } ```
     * @summary Returns the results of the job-id specified in the body payload.
     * @param {PublicapiStateRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public pkgpublicapiresults(body: PublicapiStateRequest, options?: any) {
        return JobApiFp(this.configuration).pkgpublicapiresults(body, options)(this.fetch, this.basePath);
    }

    /**
     * Example response:  ```json {   \"state\": {     \"Nodes\": {       \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\": {         \"Shards\": {           \"0\": {             \"NodeId\": \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\",             \"State\": \"Cancelled\",             \"VerificationResult\": {},             \"PublishedResults\": {}           }         }       },       \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\": {         \"Shards\": {           \"0\": {             \"NodeId\": \"QmYgxZiySj3MRkwLSL4X2MF5F9f2PMhAE3LV49XkfNL1o3\",             \"State\": \"Cancelled\",             \"VerificationResult\": {},             \"PublishedResults\": {}           }         }       },       \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\": {         \"Shards\": {           \"0\": {             \"NodeId\": \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",             \"State\": \"Completed\",             \"Status\": \"Got results proposal of length: 0\",             \"VerificationResult\": {               \"Complete\": true,               \"Result\": true             },             \"PublishedResults\": {               \"StorageSource\": \"IPFS\",               \"Name\": \"job-9304c616-291f-41ad-b862-54e133c0149e-shard-0-host-QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",               \"CID\": \"QmTVmC7JBD2ES2qGPqBNVWnX1KeEPNrPGb7rJ8cpFgtefe\"             },             \"RunOutput\": {               \"stdout\": \"Thu Nov 17 13:32:55 UTC 2022\\n\",               \"stdouttruncated\": false,               \"stderr\": \"\",               \"stderrtruncated\": false,               \"exitCode\": 0,               \"runnerError\": \"\"             }           }         }       }     }   } } ```
     * @summary Returns the state of the job-id specified in the body payload.
     * @param {PublicapiStateRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public pkgpublicapistates(body: PublicapiStateRequest, options?: any) {
        return JobApiFp(this.configuration).pkgpublicapistates(body, options)(this.fetch, this.basePath);
    }

}
/**
 * MiscApi - fetch parameter creator
 * @export
 */
export const MiscApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the id of the host node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerid(options: any = {}): FetchArgs {
            const localVarPath = `/id`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * As described in the [architecture docs](https://docs.bacalhau.org/about-bacalhau/architecture), each node is connected to a number of peer nodes.  Example response: ```json {   \"bacalhau-job-event\": [     \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",     \"QmXaXu9N5GNetatsvwnTfQqNtSeKAD6uCmarbh3LMRYAcF\",     \"QmVAb7r2pKWCuyLpYWoZr9syhhFnTWeFaByHdb8PkkhLQG\",     \"QmUDAXvv31WPZ8U9CzuRTMn9iFGiopGE7rHiah1X8a6PkT\",     \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\"   ] } ```
         * @summary Returns the peers connected to the host via the transport layer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerpeers(options: any = {}): FetchArgs {
            const localVarPath = `/peers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * See https://github.com/filecoin-project/bacalhau/releases for a complete list of `gitversion` tags.
         * @summary Returns the build version running on the server.
         * @param {PublicapiVersionRequest} body Request must specify a &#x60;client_id&#x60;. To retrieve your &#x60;client_id&#x60;, you can do the following: (1) submit a dummy job to Bacalhau (or use one you created before), (2) run &#x60;bacalhau describe &lt;job-id&gt;&#x60; and fetch the &#x60;ClientID&#x60; field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerversion(body: PublicapiVersionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiServerversion.');
            }
            const localVarPath = `/version`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PublicapiVersionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiscApi - functional programming interface
 * @export
 */
export const MiscApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the id of the host node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerid(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = MiscApiFetchParamCreator(configuration).apiServerid(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * As described in the [architecture docs](https://docs.bacalhau.org/about-bacalhau/architecture), each node is connected to a number of peer nodes.  Example response: ```json {   \"bacalhau-job-event\": [     \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",     \"QmXaXu9N5GNetatsvwnTfQqNtSeKAD6uCmarbh3LMRYAcF\",     \"QmVAb7r2pKWCuyLpYWoZr9syhhFnTWeFaByHdb8PkkhLQG\",     \"QmUDAXvv31WPZ8U9CzuRTMn9iFGiopGE7rHiah1X8a6PkT\",     \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\"   ] } ```
         * @summary Returns the peers connected to the host via the transport layer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerpeers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: Array<string>; }> {
            const localVarFetchArgs = MiscApiFetchParamCreator(configuration).apiServerpeers(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * See https://github.com/filecoin-project/bacalhau/releases for a complete list of `gitversion` tags.
         * @summary Returns the build version running on the server.
         * @param {PublicapiVersionRequest} body Request must specify a &#x60;client_id&#x60;. To retrieve your &#x60;client_id&#x60;, you can do the following: (1) submit a dummy job to Bacalhau (or use one you created before), (2) run &#x60;bacalhau describe &lt;job-id&gt;&#x60; and fetch the &#x60;ClientID&#x60; field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerversion(body: PublicapiVersionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PublicapiVersionResponse> {
            const localVarFetchArgs = MiscApiFetchParamCreator(configuration).apiServerversion(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MiscApi - factory interface
 * @export
 */
export const MiscApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Returns the id of the host node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerid(options?: any) {
            return MiscApiFp(configuration).apiServerid(options)(fetch, basePath);
        },
        /**
         * As described in the [architecture docs](https://docs.bacalhau.org/about-bacalhau/architecture), each node is connected to a number of peer nodes.  Example response: ```json {   \"bacalhau-job-event\": [     \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",     \"QmXaXu9N5GNetatsvwnTfQqNtSeKAD6uCmarbh3LMRYAcF\",     \"QmVAb7r2pKWCuyLpYWoZr9syhhFnTWeFaByHdb8PkkhLQG\",     \"QmUDAXvv31WPZ8U9CzuRTMn9iFGiopGE7rHiah1X8a6PkT\",     \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\"   ] } ```
         * @summary Returns the peers connected to the host via the transport layer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerpeers(options?: any) {
            return MiscApiFp(configuration).apiServerpeers(options)(fetch, basePath);
        },
        /**
         * See https://github.com/filecoin-project/bacalhau/releases for a complete list of `gitversion` tags.
         * @summary Returns the build version running on the server.
         * @param {PublicapiVersionRequest} body Request must specify a &#x60;client_id&#x60;. To retrieve your &#x60;client_id&#x60;, you can do the following: (1) submit a dummy job to Bacalhau (or use one you created before), (2) run &#x60;bacalhau describe &lt;job-id&gt;&#x60; and fetch the &#x60;ClientID&#x60; field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerversion(body: PublicapiVersionRequest, options?: any) {
            return MiscApiFp(configuration).apiServerversion(body, options)(fetch, basePath);
        },
    };
};

/**
 * MiscApi - object-oriented interface
 * @export
 * @class MiscApi
 * @extends {BaseAPI}
 */
export class MiscApi extends BaseAPI {
    /**
     * 
     * @summary Returns the id of the host node.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscApi
     */
    public apiServerid(options?: any) {
        return MiscApiFp(this.configuration).apiServerid(options)(this.fetch, this.basePath);
    }

    /**
     * As described in the [architecture docs](https://docs.bacalhau.org/about-bacalhau/architecture), each node is connected to a number of peer nodes.  Example response: ```json {   \"bacalhau-job-event\": [     \"QmdZQ7ZbhnvWY1J12XYKGHApJ6aufKyLNSvf8jZBrBaAVL\",     \"QmXaXu9N5GNetatsvwnTfQqNtSeKAD6uCmarbh3LMRYAcF\",     \"QmVAb7r2pKWCuyLpYWoZr9syhhFnTWeFaByHdb8PkkhLQG\",     \"QmUDAXvv31WPZ8U9CzuRTMn9iFGiopGE7rHiah1X8a6PkT\",     \"QmSyJ8VUd4YSPwZFJSJsHmmmmg7sd4BAc2yHY73nisJo86\"   ] } ```
     * @summary Returns the peers connected to the host via the transport layer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscApi
     */
    public apiServerpeers(options?: any) {
        return MiscApiFp(this.configuration).apiServerpeers(options)(this.fetch, this.basePath);
    }

    /**
     * See https://github.com/filecoin-project/bacalhau/releases for a complete list of `gitversion` tags.
     * @summary Returns the build version running on the server.
     * @param {PublicapiVersionRequest} body Request must specify a &#x60;client_id&#x60;. To retrieve your &#x60;client_id&#x60;, you can do the following: (1) submit a dummy job to Bacalhau (or use one you created before), (2) run &#x60;bacalhau describe &lt;job-id&gt;&#x60; and fetch the &#x60;ClientID&#x60; field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscApi
     */
    public apiServerversion(body: PublicapiVersionRequest, options?: any) {
        return MiscApiFp(this.configuration).apiServerversion(body, options)(this.fetch, this.basePath);
    }

}
