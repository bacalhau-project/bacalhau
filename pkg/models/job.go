//go:generate stringer -type=JobStateType --trimprefix=JobStateType --output job_string.go
package models

import (
	"errors"
	"fmt"
	"time"

	"github.com/bacalhau-project/bacalhau/pkg/lib/validate"
	"github.com/hashicorp/go-multierror"
	"golang.org/x/exp/maps"
)

type JobStateType int

const (
	JobStateTypeUndefined JobStateType = iota

	// JobStateTypePending is the state of a job that has been submitted but not
	// yet scheduled.
	JobStateTypePending

	// JobStateTypeRunning is the state of a job that has been scheduled, with at
	// least one active execution.
	JobStateTypeRunning

	// JobStateTypeCompleted is the state of a job that has successfully completed.
	// Only valid for batch jobs.
	JobStateTypeCompleted

	// JobStateTypeFailed is the state of a job that has failed.
	JobStateTypeFailed

	// JobStateTypeStopped is the state of a job that has been stopped by the user.
	JobStateTypeStopped
)

// IsUndefined returns true if the job state is undefined
func (s JobStateType) IsUndefined() bool {
	return s == JobStateTypeUndefined
}

type Job struct {
	// ID is a unique identifier assigned to this job.
	// It helps to distinguish jobs with the same name after they have been deleted and re-created.
	//The ID is generated by the server and should not be set directly by the client.
	ID string

	// Name is the logical name of the job used to refer to it.
	// Submitting a job with the same name as an existing job will result in an
	// update to the existing job.
	Name string

	// Namespace is the namespace this job is running in.
	Namespace string

	// Type is the type of job this is, e.g. "daemon" or "batch".
	Type string

	// Priority defines the scheduling priority of this job.
	Priority int

	// Count is the number of replicas that should be scheduled.
	Count int

	// Constraints is a selector which must be true for the compute node to run this job.
	Constraints []*LabelSelectorRequirement

	// Meta is used to associate arbitrary metadata with this job.
	Meta map[string]string

	// Labels is used to associate arbitrary labels with this job, which can be used
	// for filtering.
	Labels map[string]string

	Tasks []*Task

	// State is the current state of the job.
	State State[JobStateType]

	// Version is a per-job monotonically increasing version number that is incremented
	// on each job specification update.
	Version uint64

	// Revision is a per-job monotonically increasing revision number that is incremented
	// on each update to the job's state or specification
	Revision uint64

	CreateTime int64
	ModifyTime int64
}

func (j *Job) String() string {
	return j.ID
}

// NamespacedID returns the namespaced id useful for logging
func (j *Job) NamespacedID() NamespacedID {
	return NamespacedID{
		ID:        j.ID,
		Namespace: j.Namespace,
	}
}

// Normalize is used to canonicalize fields in the Job. This should be
// called when registering a Job.
func (j *Job) Normalize() {
	if j == nil {
		return
	}

	// Ensure that an empty and nil map are treated the same to avoid scheduling
	// problems since we use reflect DeepEquals.
	if j.Meta == nil {
		j.Meta = make(map[string]string)
	}

	if j.Labels == nil {
		j.Labels = make(map[string]string)
	}

	if j.Constraints == nil {
		j.Constraints = make([]*LabelSelectorRequirement, 0)
	}

	if j.Tasks == nil {
		j.Tasks = make([]*Task, 0)
	}

	// Ensure the job is in a namespace.
	if j.Namespace == "" {
		j.Namespace = DefaultNamespace
	}

	if (j.Type == JobTypeDaemon || j.Type == JobTypeOps) && j.Count == 0 {
		j.Count = 1
	}

	for _, task := range j.Tasks {
		task.Normalize()
	}
}

// Copy returns a deep copy of the Job. It is expected that callers use recover.
// This job can panic if the deep copy failed as it uses reflection.
func (j *Job) Copy() *Job {
	if j == nil {
		return nil
	}
	nj := new(Job)
	*nj = *j
	nj.Constraints = CopySlice[*LabelSelectorRequirement](nj.Constraints)

	if j.Tasks != nil {
		tasks := make([]*Task, len(nj.Tasks))
		for i, t := range nj.Tasks {
			tasks[i] = t.Copy()
		}
		nj.Tasks = tasks
	}

	nj.Meta = maps.Clone(nj.Meta)
	return nj
}

// Validate is used to check a job for reasonable configuration
func (j *Job) Validate() error {
	mErr := new(multierror.Error)
	if validate.IsBlank(j.ID) {
		mErr.Errors = append(mErr.Errors, errors.New("missing job ID"))
	} else if validate.ContainsSpaces(j.ID) {
		mErr.Errors = append(mErr.Errors, errors.New("job ID contains a space"))
	} else if validate.ContainsNull(j.ID) {
		mErr.Errors = append(mErr.Errors, errors.New("job ID contains a null character"))
	}
	mErr = multierror.Append(mErr, j.ValidateSubmission())
	return mErr.ErrorOrNil()
}

// ValidateSubmission is used to check a job for reasonable configuration when it is submitted.
// It is a subset of Validate, but job ID is optional as it can be generated by the server
func (j *Job) ValidateSubmission() error {
	var mErr multierror.Error
	if validate.IsBlank(j.Name) {
		mErr.Errors = append(mErr.Errors, errors.New("missing job name"))
	} else if validate.ContainsNull(j.Name) {
		mErr.Errors = append(mErr.Errors, errors.New("job Name contains a null character"))
	}
	if validate.IsBlank(j.Namespace) {
		mErr.Errors = append(mErr.Errors, errors.New("job must be in a namespace"))
	}
	switch j.Type {
	case JobTypeService, JobTypeBatch, JobTypeDaemon, JobTypeOps:
	case "":
		mErr.Errors = append(mErr.Errors, errors.New("missing job type"))
	default:
		mErr.Errors = append(mErr.Errors, fmt.Errorf("invalid job type: %q", j.Type))
	}

	if j.Count < 0 {
		mErr.Errors = append(mErr.Errors, errors.New("job count must be >= 0"))
	}
	if len(j.Tasks) == 0 {
		mErr.Errors = append(mErr.Errors, errors.New("missing job tasks"))
	}
	for idx, constr := range j.Constraints {
		if err := constr.Validate(); err != nil {
			outer := fmt.Errorf("constraint %d validation failed: %s", idx+1, err)
			mErr.Errors = append(mErr.Errors, outer)
		}
	}

	// Validate the task group
	for _, task := range j.Tasks {
		if err := task.Validate(); err != nil {
			outer := fmt.Errorf("task %s validation failed: %v", task.Name, err)
			mErr.Errors = append(mErr.Errors, outer)
		}
	}

	return mErr.ErrorOrNil()
}

// IsTerminal returns true if the job is in a terminal state
func (j *Job) IsTerminal() bool {
	switch j.State.StateType {
	case JobStateTypeCompleted, JobStateTypeFailed, JobStateTypeStopped:
		return true
	default:
		return false
	}
}

// Task returns the job task
// TODO: remove this once we have multiple tasks per job
func (j *Job) Task() *Task {
	if j == nil {
		return nil
	}
	return j.Tasks[0]
}

// GetCreateTime returns the creation time
func (j *Job) GetCreateTime() time.Time {
	return time.Unix(0, j.CreateTime).UTC()
}

// GetModifyTime returns the modify time
func (j *Job) GetModifyTime() time.Time {
	return time.Unix(0, j.ModifyTime).UTC()
}

// AllStorageTypes returns keys of all storage types required by the job
func (j *Job) AllStorageTypes() []string {
	var storageTypes []string
	if j == nil {
		return storageTypes
	}
	for _, task := range j.Tasks {
		storageTypes = append(storageTypes, task.AllStorageTypes()...)
	}
	return storageTypes
}
