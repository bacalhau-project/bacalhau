//go:generate stringer -type=JobStateType --trimprefix=JobStateType --output job_string.go
package models

import (
	"errors"
	"fmt"

	"github.com/bacalhau-project/bacalhau/pkg/lib/validate"
	"github.com/hashicorp/go-multierror"
	"golang.org/x/exp/maps"
)

type JobStateType int

const (
	JobStateTypeUnknown JobStateType = iota

	// JobStateTypePending is the state of a job that has been submitted but not
	// yet scheduled.
	JobStateTypePending

	// JobStateTypeRunning is the state of a job that has been scheduled, with at
	// least one active execution.
	JobStateTypeRunning

	// JobStateTypeCompleted is the state of a job that has successfully completed.
	// Only valid for batch jobs.
	JobStateTypeCompleted

	// JobStateTypeFailed is the state of a job that has failed.
	JobStateTypeFailed

	// JobStateTypeStopped is the state of a job that has been stopped by the user.
	JobStateTypeStopped
)

type Job struct {
	// ID is a unique identifier assigned to this job.
	// It helps to distinguish jobs with the same name after they have been deleted and re-created.
	//The ID is generated by the server and should not be set directly by the client.
	ID string

	// Name is the logical name of the job used to refer to it.
	// Submitting a job with the same name as an existing job will result in an
	// update to the existing job.
	Name string

	// Namespace is the namespace this job is running in.
	Namespace string

	// Type is the type of job this is, e.g. "daemon" or "batch".
	Type string

	// Priority defines the scheduling priority of this job.
	Priority int

	// Count is the number of replicas that should be scheduled.
	Count int

	// Constraints is a selector which must be true for the compute node to run this job.
	Constraints []*LabelSelectorRequirement

	// Meta is used to associate arbitrary metadata with this job.
	Meta map[string]string

	Tasks []*Task

	// State is the current state of the job.
	State JobStateType

	// StateDescription is meant to provide more human useful information
	StateDescription string

	// Version is a monotonically increasing version number that is incremented
	// on each job update.
	Version uint64

	CreateTime int64
	ModifyTime int64
}

// NamespacedID returns the namespaced id useful for logging
func (j *Job) NamespacedID() NamespacedID {
	return NamespacedID{
		ID:        j.ID,
		Namespace: j.Namespace,
	}
}

// Normalize is used to canonicalize fields in the Job. This should be
// called when registering a Job.
func (j *Job) Normalize() {
	if j == nil {
		return
	}

	// Ensure that an empty and nil map are treated the same to avoid scheduling
	// problems since we use reflect DeepEquals.
	if len(j.Meta) == 0 {
		j.Meta = nil
	}

	// Ensure the job is in a namespace.
	if j.Namespace == "" {
		j.Namespace = DefaultNamespace
	}

	if (j.Type == JobTypeDaemon || j.Type == JobTypeOps) && j.Count == 0 {
		j.Count = 1
	}

	for _, task := range j.Tasks {
		task.Normalize(j)
	}
}

// Copy returns a deep copy of the Job. It is expected that callers use recover.
// This job can panic if the deep copy failed as it uses reflection.
func (j *Job) Copy() *Job {
	if j == nil {
		return nil
	}
	nj := new(Job)
	*nj = *j
	nj.Constraints = CopySlice[*LabelSelectorRequirement](nj.Constraints)

	if j.Tasks != nil {
		tasks := make([]*Task, len(nj.Tasks))
		for i, t := range nj.Tasks {
			tasks[i] = t.Copy()
		}
		nj.Tasks = tasks
	}

	nj.Meta = maps.Clone(nj.Meta)
	return nj
}

// Validate is used to check a job for reasonable configuration
func (j *Job) Validate() error {
	var mErr multierror.Error
	if validate.IsBlank(j.ID) {
		mErr.Errors = append(mErr.Errors, errors.New("missing job ID"))
	} else if validate.ContainsSpaces(j.ID) {
		mErr.Errors = append(mErr.Errors, errors.New("job ID contains a space"))
	} else if validate.ContainsNull(j.ID) {
		mErr.Errors = append(mErr.Errors, errors.New("job ID contains a null character"))
	}
	if validate.IsBlank(j.Name) {
		mErr.Errors = append(mErr.Errors, errors.New("missing job name"))
	} else if validate.ContainsNull(j.Name) {
		mErr.Errors = append(mErr.Errors, errors.New("job Name contains a null character"))
	}
	if validate.IsBlank(j.Namespace) {
		mErr.Errors = append(mErr.Errors, errors.New("job must be in a namespace"))
	}
	switch j.Type {
	case JobTypeService, JobTypeBatch, JobTypeDaemon, JobTypeOps:
	case "":
		mErr.Errors = append(mErr.Errors, errors.New("missing job type"))
	default:
		mErr.Errors = append(mErr.Errors, fmt.Errorf("invalid job type: %q", j.Type))
	}

	if j.Count < 0 {
		mErr.Errors = append(mErr.Errors, errors.New("job count must be >= 0"))
	}
	if len(j.Tasks) == 0 {
		mErr.Errors = append(mErr.Errors, errors.New("missing job tasks"))
	}
	for idx, constr := range j.Constraints {
		if err := constr.Validate(); err != nil {
			outer := fmt.Errorf("constraint %d validation failed: %s", idx+1, err)
			mErr.Errors = append(mErr.Errors, outer)
		}
	}

	// Validate the task group
	for _, task := range j.Tasks {
		if err := task.Validate(j); err != nil {
			outer := fmt.Errorf("task %s validation failed: %v", task.Name, err)
			mErr.Errors = append(mErr.Errors, outer)
		}
	}

	return mErr.ErrorOrNil()
}
