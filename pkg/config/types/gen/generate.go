package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"strings"

	"github.com/bacalhau-project/bacalhau/pkg/config/types"
)

// processStructFields processes the fields of a struct type using the provided handler function.
func processStructFields(t reflect.Type, prefix string, file *os.File, handleLeafNode func(field reflect.StructField, newPrefix string)) {
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		tag := field.Tag.Get("config")
		newPrefix := prefix

		if tag != "" {
			if newPrefix != "" {
				newPrefix += "."
			}
			newPrefix += tag
		} else if !field.Anonymous {
			if newPrefix != "" {
				newPrefix += "."
			}
			newPrefix += field.Name
		}

		if field.Type.Kind() == reflect.Struct {
			// Recursively process nested structs
			processStructFields(field.Type, newPrefix, file, handleLeafNode)
		} else {
			// Handle leaf node
			handleLeafNode(field, newPrefix)
		}
	}
}

// generateConstants generates constant definitions for each leaf field in the given struct type.
func generateConstants(t reflect.Type, prefix string, file *os.File) {
	handleLeafNode := func(field reflect.StructField, newPrefix string) {
		constantName := strings.ReplaceAll(newPrefix, ".", "")
		constantValue := strings.ToLower(newPrefix)
		fmt.Fprintf(file, "const %sKey = \"%s\"\n", constantName, constantValue)
	}
	processStructFields(t, prefix, file, handleLeafNode)
}

// generateDescriptions generates the map of configuration descriptions.
func generateDescriptions(t reflect.Type, prefix string, file *os.File) {
	handleLeafNode := func(field reflect.StructField, newPrefix string) {
		description := commentsMap[field.Name]
		if description == "" {
			description = "No description available"
		} else {
			// Clean up the comment: remove leading "//" and newlines
			description = strings.TrimPrefix(description, "//")
			description = strings.ReplaceAll(description, "\n", " ")
			description = strings.TrimSpace(description)
			description = escapeString(description)
		}

		constantName := strings.ReplaceAll(newPrefix, ".", "")
		fmt.Fprintf(file, "\t%sKey: \"%s\",\n", constantName, description)
	}
	processStructFields(t, prefix, file, handleLeafNode)
}

var commentsMap = make(map[string]string)

// extractComments extracts comments from the source files in the provided directory.
func extractComments(dir string) error {
	fset := token.NewFileSet()
	packages, err := parser.ParseDir(fset, dir, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("error parsing directory %s: %w", dir, err)
	}

	for _, pkg := range packages {
		for _, file := range pkg.Files {
			ast.Inspect(file, func(n ast.Node) bool {
				switch x := n.(type) {
				case *ast.TypeSpec:
					if x.Doc != nil {
						commentsMap[x.Name.Name] = strings.TrimSpace(x.Doc.Text())
					}
				case *ast.Field:
					if x.Doc != nil && len(x.Names) > 0 {
						commentsMap[x.Names[0].Name] = strings.TrimSpace(x.Doc.Text())
					}
				}
				return true
			})
		}
	}
	return nil
}

// escapeString escapes double quotes in the string for safe inclusion in Go source code.
func escapeString(s string) string {
	return strings.ReplaceAll(s, `"`, `\"`)
}

func main() {
	if len(os.Args) != 2 {
		fmt.Println("Please provide the path to the config directory.")
		os.Exit(1)
	}
	inputDir := os.Args[1]

	// Extract comments from all source files in the directory
	err := extractComments(inputDir)
	if err != nil {
		panic(err)
	}

	// Generate constants file
	constantsFile, err := os.Create(filepath.Join(inputDir, "generated_constants.go"))
	if err != nil {
		panic(err)
	}
	defer constantsFile.Close()

	// Write the package declaration
	fmt.Fprintf(constantsFile, "// CODE GENERATED BY pkg/config/types/gen_paths DO NOT EDIT\n\n")
	fmt.Fprintf(constantsFile, "package types\n\n")

	generateConstants(reflect.TypeOf(types.Bacalhau{}), "", constantsFile)

	// Generate descriptions file
	descriptionsFile, err := os.Create(filepath.Join(inputDir, "generated_descriptions.go"))
	if err != nil {
		panic(err)
	}
	defer descriptionsFile.Close()

	// Write the package declaration
	fmt.Fprintf(descriptionsFile, "// Code generated by go generate; DO NOT EDIT.\n\n")
	fmt.Fprintf(descriptionsFile, "package types\n\n")

	fmt.Fprintf(descriptionsFile, "// ConfigDescriptions maps configuration paths to their descriptions\n")
	fmt.Fprintf(descriptionsFile, "var ConfigDescriptions = map[string]string{\n")

	generateDescriptions(reflect.TypeOf(types.Bacalhau{}), "", descriptionsFile)

	fmt.Fprintf(descriptionsFile, "}\n")

	fmt.Printf("Generated files written to %s\n", inputDir)
}
