package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"
)

func main() {
	// Replace with the actual path to your Go source files
	pkgPath := "/home/frrist/workspace/src/github.com/bacalhau-project/bacalhau/pkg/config/types"

	fieldComments := ConfigFieldMap(pkgPath)

	// Output the field path to comment map in sorted order
	var paths []string
	for path := range fieldComments {
		paths = append(paths, path)
	}
	sort.Strings(paths)
	for _, path := range paths {
		comment := fieldComments[path]
		log.Printf("%s: %s", path, comment)
	}

	// Generate constants file
	constantsFile, err := os.Create(filepath.Join(pkgPath, "generated_constants.go"))
	if err != nil {
		panic(err)
	}
	defer constantsFile.Close()
	if err := WriteConstants(fieldComments, constantsFile); err != nil {
		panic(err)
	}

}

func WriteConstants(fieldComments map[string]string, w io.Writer) error {
	// Collect and sort the keys
	var keys []string
	for key := range fieldComments {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	var builder strings.Builder
	builder.WriteString("// CODE GENERATED BY pkg/config/types/gen/generate.go DO NOT EDIT\n\n")
	builder.WriteString("package types\n\n")
	// Generate constant declarations
	for _, key := range keys {
		constName := generateConstantName(key)
		builder.WriteString(fmt.Sprintf("const %s = \"%s\"\n", constName, key))
	}
	// Write the content to the specified file
	if _, err := io.WriteString(w, builder.String()); err != nil {
		return err
	}

	return nil
}

// generateConstantName converts a field path to a constant name
func generateConstantName(fieldPath string) string {
	// Split the field path by "."
	parts := strings.Split(fieldPath, ".")
	// Capitalize each part
	for i, part := range parts {
		parts[i] = capitalize(part)
	}
	// Join the parts and append "Key"
	constName := strings.Join(parts, "") + "Key"
	return constName
}

// capitalize capitalizes the first letter of a string
func capitalize(s string) string {
	if s == "" {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func ConfigFieldMap(dir string) map[string]string {
	// Parse the package directory
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	fieldComments := make(map[string]string)
	typeMap := make(map[string]*ast.StructType)

	// Build a map of type names to *ast.StructType
	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			ast.Inspect(file, func(n ast.Node) bool {
				// Look for type declarations
				genDecl, ok := n.(*ast.GenDecl)
				if !ok || genDecl.Tok != token.TYPE {
					return true
				}
				for _, spec := range genDecl.Specs {
					typeSpec, ok := spec.(*ast.TypeSpec)
					if !ok {
						continue
					}
					structType, ok := typeSpec.Type.(*ast.StructType)
					if !ok {
						continue
					}
					structName := typeSpec.Name.Name
					typeMap[structName] = structType
				}
				return false
			})
		}
	}

	// Start processing from the Bacalhau struct
	if bacalhauStruct, ok := typeMap["Bacalhau"]; ok {
		processStruct("", bacalhauStruct, fieldComments, typeMap)
	} else {
		log.Fatal("Could not find Bacalhau struct")
	}

	// Output the field path to comment map in sorted order
	var paths []string
	for path := range fieldComments {
		paths = append(paths, path)
	}
	return fieldComments
}

func processStruct(prefix string, structType *ast.StructType, fieldComments map[string]string, typeMap map[string]*ast.StructType) {
	for _, field := range structType.Fields.List {
		// Get field names
		var fieldNames []string
		if len(field.Names) > 0 {
			for _, name := range field.Names {
				fieldNames = append(fieldNames, name.Name)
			}
		} else {
			// Embedded field
			switch t := field.Type.(type) {
			case *ast.Ident:
				fieldNames = append(fieldNames, t.Name)
			case *ast.StarExpr:
				if ident, ok := t.X.(*ast.Ident); ok {
					fieldNames = append(fieldNames, ident.Name)
				}
			}
		}

		// Extract comment
		comment := ""
		if field.Doc != nil {
			comment = strings.TrimSpace(field.Doc.Text())
		} else if field.Comment != nil {
			comment = strings.TrimSpace(field.Comment.Text())
		}

		// Extract YAML tag
		tag := ""
		if field.Tag != nil {
			tagValue := strings.Trim(field.Tag.Value, "`")
			structTag := reflect.StructTag(tagValue)
			yamlTag := structTag.Get("yaml")
			if yamlTag != "" {
				tag = strings.Split(yamlTag, ",")[0]
			}
		}

		for _, name := range fieldNames {
			// Use YAML tag or field name
			tagOrName := strings.ToLower(tag)
			if tagOrName == "" {
				tagOrName = strings.ToLower(name)
			}

			// Build field path
			var fieldPath string
			if prefix != "" {
				fieldPath = prefix + "." + tagOrName
			} else {
				fieldPath = tagOrName
			}

			// Determine if the field is a leaf (non-struct) field
			isLeaf := true
			switch ft := field.Type.(type) {
			case *ast.Ident:
				if _, ok := typeMap[ft.Name]; ok {
					// Field is a named struct type
					isLeaf = false
				}
			case *ast.StarExpr:
				if ident, ok := ft.X.(*ast.Ident); ok {
					if _, ok := typeMap[ident.Name]; ok {
						// Field is a pointer to a named struct type
						isLeaf = false
					}
				}
			case *ast.StructType:
				// Field is an anonymous struct
				isLeaf = false
			}

			// If it's a leaf field, store the comment
			if isLeaf {
				fieldComments[fieldPath] = comment
			} else {
				// Recursively process nested structs
				switch ft := field.Type.(type) {
				case *ast.Ident:
					if nestedStruct, ok := typeMap[ft.Name]; ok {
						processStruct(fieldPath, nestedStruct, fieldComments, typeMap)
					}
				case *ast.StarExpr:
					if ident, ok := ft.X.(*ast.Ident); ok {
						if nestedStruct, ok := typeMap[ident.Name]; ok {
							processStruct(fieldPath, nestedStruct, fieldComments, typeMap)
						}
					}
				case *ast.StructType:
					processStruct(fieldPath, ft, fieldComments, typeMap)
				}
			}
		}
	}
}
