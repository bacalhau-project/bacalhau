package models

import (
	"maps"
	"time"
)

// EventTopic is a high level categorisation that can be applied to an event. It
// should be a human-readable string with no dynamic content. They are used to
// disambiguate events from the same component occurring in different contexts.
// For example, an event emitted by S3 storage used as an input source and the
// same event emitted by S3 storage used as a publisher would be tagged with
// different topics.
//
// EventTopics do not need to conform to a centralized list – each module should
// use event topics that make sense for their own logic. Event topics SHOULD be
// unique.
type EventTopic string

// Event represents a progress report made by the system in its attempt to run a
// job. Events are generated by the orchestrator and also passed back to the
// orchestrator from the compute node.
//
// Events may be delivered in an async fashion – i.e, they may arrive much later
// than the moment they occurred.
type Event struct {
	// A human-readable string giving the user all the information they need to
	// understand and respond to an Event, if a response is required.
	Message string `json:"Message"`

	// The topic of the event. See the documentation on EventTopic.
	Topic EventTopic `json:"Topic"`

	// The moment the event occurred, which may be different to the moment it
	// was recorded.
	Timestamp time.Time `json:"Timestamp"`

	// Any additional metadata that the system or user may need to know about
	// the event in order to handle it properly.
	Details map[string]string `json:"Details,omitempty"`
}

// NewEvent returns a new Event with the given topic.
func NewEvent(topic EventTopic) *Event {
	return &Event{
		Topic:     topic,
		Timestamp: time.Now(),
		Details:   make(map[string]string),
	}
}

// WithMessage returns a new Event with the given message and topic.
func (e *Event) WithMessage(message string) *Event {
	e.Message = message
	return e
}

// WithError returns a new Event with the given error.
func (e *Event) WithError(err error) *Event {
	e.Message = err.Error()
	return e.WithDetail(DetailsKeyIsError, "true")
}

// WithHint returns a new Event with the given hint.
func (e *Event) WithHint(hint string) *Event {
	if hint != "" {
		return e.WithDetail(DetailsKeyHint, hint)
	}
	return e
}

// WithRetryable returns a new Event with the given retryable flag.
func (e *Event) WithRetryable(retryable bool) *Event {
	if retryable {
		return e.WithDetail(DetailsKeyRetryable, "true")
	}
	return e
}

// WithFailsExecution returns a new Event with the given fails execution flag.
func (e *Event) WithFailsExecution(failsExecution bool) *Event {
	if failsExecution {
		return e.WithDetail(DetailsKeyFailsExecution, "true")
	}
	return e
}

// WithDetails returns a new Event with the given details and topic.
func (e *Event) WithDetails(details map[string]string) *Event {
	maps.Copy(e.Details, details)
	return e
}

// WithDetail returns a new Event with the given detail and topic.
func (e *Event) WithDetail(key, value string) *Event {
	e.Details[key] = value
	return e
}

// EventFromError converts an error into an Event tagged with the passed event
// topic.
//
// This method allows errors to implement extra interfaces (above) to do
// "attribute-based error reporting". The design principle is that errors can
// report a set of extra flags that have well defined semantics which the system
// can then respond to with specific behavior. This allows introducing or
// refactoring error types without higher-level components needing to be
// modified – they simply continue to respond to the presence of attributes.
//
// This is instead of the system having a centralized set of known error types
// and programming in specific behavior in response to them, which is brittle
// and requires updating all of the error responses when the types change.
func EventFromError(topic EventTopic, err error) Event {
	event := NewEvent(topic).WithError(err)

	if hasDetails, ok := err.(HasDetails); ok {
		event = event.WithDetails(hasDetails.Details())
	}
	if hasHint, ok := err.(HasHint); ok {
		event = event.WithHint(hasHint.Hint())
	}
	if hasRetryable, ok := err.(HasRetryable); ok {
		event = event.WithRetryable(hasRetryable.Retryable())
	}
	if hasFailsExecution, ok := err.(HasFailsExecution); ok {
		event = event.WithFailsExecution(hasFailsExecution.FailsExecution())
	}

	return *event
}
