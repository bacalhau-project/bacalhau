// This file is auto-generated by @hey-api/openapi-ts

export const apimodels_GetJobResponseSchema = {
    type: 'object',
    properties: {
        Executions: {
            '$ref': '#/definitions/apimodels.ListJobExecutionsResponse'
        },
        History: {
            '$ref': '#/definitions/apimodels.ListJobHistoryResponse'
        },
        Job: {
            '$ref': '#/definitions/models.Job'
        }
    }
} as const;

export const apimodels_GetNodeResponseSchema = {
    type: 'object',
    properties: {
        node: {
            '$ref': '#/definitions/models.NodeState'
        }
    }
} as const;

export const apimodels_GetVersionResponseSchema = {
    type: 'object',
    properties: {
        BuildDate: {
            type: 'string',
            example: '2022-11-16T14:03:31Z'
        },
        GOARCH: {
            type: 'string',
            example: 'amd64'
        },
        GOOS: {
            type: 'string',
            example: 'linux'
        },
        GitCommit: {
            type: 'string',
            example: 'd612b63108f2b5ce1ab2b9e02444eb1dac1d922d'
        },
        GitVersion: {
            type: 'string',
            example: 'v0.3.12'
        },
        Major: {
            type: 'string',
            example: '0'
        },
        Minor: {
            type: 'string',
            example: '3'
        }
    }
} as const;

export const apimodels_HTTPCredentialSchema = {
    type: 'object',
    properties: {
        params: {
            description: `For authorization schemes that provide multiple values, a map of names to
values providing the credential`,
            type: 'object',
            additionalProperties: {
                type: 'string'
            }
        },
        scheme: {
            description: `An HTTP authorization scheme, such as one registered with IANA
https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml`,
            type: 'string'
        },
        value: {
            description: `For authorization schemes that only provide a single value, such as
Basic, the single string value providing the credential`,
            type: 'string'
        }
    }
} as const;

export const apimodels_ListJobExecutionsResponseSchema = {
    type: 'object',
    properties: {
        Items: {
            type: 'array',
            items: {
                '$ref': '#/definitions/models.Execution'
            }
        },
        NextToken: {
            type: 'string'
        }
    }
} as const;

export const apimodels_ListJobHistoryResponseSchema = {
    type: 'object',
    properties: {
        Items: {
            type: 'array',
            items: {
                '$ref': '#/definitions/models.JobHistory'
            }
        },
        NextToken: {
            type: 'string'
        }
    }
} as const;

export const apimodels_ListJobResultsResponseSchema = {
    type: 'object',
    properties: {
        Items: {
            type: 'array',
            items: {
                '$ref': '#/definitions/models.SpecConfig'
            }
        },
        NextToken: {
            type: 'string'
        }
    }
} as const;

export const apimodels_ListJobsResponseSchema = {
    type: 'object',
    properties: {
        Items: {
            type: 'array',
            items: {
                '$ref': '#/definitions/models.Job'
            }
        },
        NextToken: {
            type: 'string'
        }
    }
} as const;

export const apimodels_ListNodesResponseSchema = {
    type: 'object',
    properties: {
        NextToken: {
            type: 'string'
        },
        nodes: {
            type: 'array',
            items: {
                '$ref': '#/definitions/models.NodeState'
            }
        }
    }
} as const;

export const apimodels_PutJobRequestSchema = {
    type: 'object',
    properties: {
        Job: {
            '$ref': '#/definitions/models.Job'
        },
        credential: {
            '$ref': '#/definitions/apimodels.HTTPCredential'
        },
        idempotencyToken: {
            type: 'string'
        },
        namespace: {
            type: 'string'
        }
    }
} as const;

export const apimodels_PutJobResponseSchema = {
    type: 'object',
    properties: {
        EvaluationID: {
            type: 'string'
        },
        JobID: {
            type: 'string'
        },
        Warnings: {
            type: 'array',
            items: {
                type: 'string'
            }
        }
    }
} as const;

export const apimodels_PutNodeRequestSchema = {
    type: 'object',
    properties: {
        action: {
            type: 'string'
        },
        credential: {
            '$ref': '#/definitions/apimodels.HTTPCredential'
        },
        idempotencyToken: {
            type: 'string'
        },
        message: {
            type: 'string'
        },
        namespace: {
            type: 'string'
        },
        nodeID: {
            type: 'string'
        }
    }
} as const;

export const apimodels_PutNodeResponseSchema = {
    type: 'object',
    properties: {
        error: {
            type: 'string'
        },
        success: {
            type: 'boolean'
        }
    }
} as const;

export const apimodels_StopJobResponseSchema = {
    type: 'object',
    properties: {
        EvaluationID: {
            type: 'string'
        }
    }
} as const;

export const authn_MethodTypeSchema = {
    type: 'string',
    enum: ['challenge', 'ask'],
    'x-enum-varnames': ['MethodTypeChallenge', 'MethodTypeAsk']
} as const;

export const logger_LogModeSchema = {
    type: 'string',
    enum: ['default', 'station', 'json', 'combined', 'event'],
    'x-enum-varnames': ['LogModeDefault', 'LogModeStation', 'LogModeJSON', 'LogModeCombined', 'LogModeEvent']
} as const;

export const models_AllocatedResourcesSchema = {
    type: 'object',
    properties: {
        Tasks: {
            type: 'object',
            additionalProperties: {
                '$ref': '#/definitions/models.Resources'
            }
        }
    }
} as const;

export const models_BuildVersionInfoSchema = {
    type: 'object',
    properties: {
        BuildDate: {
            type: 'string',
            example: '2022-11-16T14:03:31Z'
        },
        GOARCH: {
            type: 'string',
            example: 'amd64'
        },
        GOOS: {
            type: 'string',
            example: 'linux'
        },
        GitCommit: {
            type: 'string',
            example: 'd612b63108f2b5ce1ab2b9e02444eb1dac1d922d'
        },
        GitVersion: {
            type: 'string',
            example: 'v0.3.12'
        },
        Major: {
            type: 'string',
            example: '0'
        },
        Minor: {
            type: 'string',
            example: '3'
        }
    }
} as const;

export const models_ComputeNodeInfoSchema = {
    type: 'object',
    properties: {
        AvailableCapacity: {
            '$ref': '#/definitions/models.Resources'
        },
        EnqueuedExecutions: {
            type: 'integer'
        },
        ExecutionEngines: {
            type: 'array',
            items: {
                type: 'string'
            }
        },
        MaxCapacity: {
            '$ref': '#/definitions/models.Resources'
        },
        MaxJobRequirements: {
            '$ref': '#/definitions/models.Resources'
        },
        Publishers: {
            type: 'array',
            items: {
                type: 'string'
            }
        },
        QueueCapacity: {
            '$ref': '#/definitions/models.Resources'
        },
        RunningExecutions: {
            type: 'integer'
        },
        StorageSources: {
            type: 'array',
            items: {
                type: 'string'
            }
        }
    }
} as const;

export const models_DebugInfoSchema = {
    type: 'object',
    properties: {
        component: {
            type: 'string'
        },
        info: {}
    }
} as const;

export const models_EventSchema = {
    type: 'object',
    properties: {
        Details: {
            description: `Any additional metadata that the system or user may need to know about
the event in order to handle it properly.`,
            type: 'object',
            additionalProperties: {
                type: 'string'
            }
        },
        Message: {
            description: `A human-readable string giving the user all the information they need to
understand and respond to an Event, if a response is required.`,
            type: 'string'
        },
        Timestamp: {
            description: `The moment the event occurred, which may be different to the moment it
was recorded.`,
            type: 'string'
        },
        Topic: {
            description: 'The topic of the event. See the documentation on EventTopic.',
            type: 'string'
        }
    }
} as const;

export const models_ExecutionSchema = {
    type: 'object',
    properties: {
        AllocatedResources: {
            description: 'AllocatedResources is the total resources allocated for the execution tasks.',
            allOf: [
                {
                    '$ref': '#/definitions/models.AllocatedResources'
                }
            ]
        },
        ComputeState: {
            description: 'ComputeState observed state of the execution on the compute node',
            allOf: [
                {
                    '$ref': '#/definitions/models.State-models_ExecutionStateType'
                }
            ]
        },
        CreateTime: {
            description: `CreateTime is the time the execution has finished scheduling and been
verified by the plan applier.`,
            type: 'integer'
        },
        DesiredState: {
            description: 'DesiredState of the execution on the compute node',
            allOf: [
                {
                    '$ref': '#/definitions/models.State-models_ExecutionDesiredStateType'
                }
            ]
        },
        EvalID: {
            description: 'ID of the evaluation that generated this execution',
            type: 'string'
        },
        FollowupEvalID: {
            description: `FollowupEvalID captures a follow up evaluation created to handle a failed execution
that can be rescheduled in the future`,
            type: 'string'
        },
        ID: {
            description: 'ID of the execution (UUID)',
            type: 'string'
        },
        Job: {
            description: 'TODO: evaluate using a copy of the job instead of a pointer',
            allOf: [
                {
                    '$ref': '#/definitions/models.Job'
                }
            ]
        },
        JobID: {
            description: `Job is the parent job of the task being allocated.
This is copied at execution time to avoid issues if the job
definition is updated.`,
            type: 'string'
        },
        ModifyTime: {
            description: 'ModifyTime is the time the execution was last updated.',
            type: 'integer'
        },
        Name: {
            description: 'Name is a logical name of the execution.',
            type: 'string'
        },
        Namespace: {
            description: 'Namespace is the namespace the execution is created in',
            type: 'string'
        },
        NextExecution: {
            description: 'NextExecution is the execution that this execution is being replaced by',
            type: 'string'
        },
        NodeID: {
            description: 'NodeID is the node this is being placed on',
            type: 'string'
        },
        PreviousExecution: {
            description: 'PreviousExecution is the execution that this execution is replacing',
            type: 'string'
        },
        PublishedResult: {
            description: 'the published results for this execution',
            allOf: [
                {
                    '$ref': '#/definitions/models.SpecConfig'
                }
            ]
        },
        Revision: {
            description: 'Revision is increment each time the execution is updated.',
            type: 'integer'
        },
        RunOutput: {
            description: `RunOutput is the output of the run command
TODO: evaluate removing this from execution spec in favour of calling \`bacalhau job logs\``,
            allOf: [
                {
                    '$ref': '#/definitions/models.RunCommandResult'
                }
            ]
        }
    }
} as const;

export const models_ExecutionDesiredStateTypeSchema = {
    type: 'integer',
    enum: [0, 1, 2],
    'x-enum-varnames': ['ExecutionDesiredStatePending', 'ExecutionDesiredStateRunning', 'ExecutionDesiredStateStopped']
} as const;

export const models_ExecutionLogSchema = {
    type: 'object',
    properties: {
        line: {
            type: 'string'
        },
        type: {
            '$ref': '#/definitions/models.ExecutionLogType'
        }
    }
} as const;

export const models_ExecutionLogTypeSchema = {
    type: 'integer',
    enum: [0, 1, 2],
    'x-enum-varnames': ['executionLogTypeUnknown', 'ExecutionLogTypeSTDOUT', 'ExecutionLogTypeSTDERR']
} as const;

export const models_ExecutionStateTypeSchema = {
    type: 'integer',
    enum: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    'x-enum-comments': {
        ExecutionStateBidAccepted: 'aka running'
    },
    'x-enum-varnames': ['ExecutionStateUndefined', 'ExecutionStateNew', 'ExecutionStateAskForBid', 'ExecutionStateAskForBidAccepted', 'ExecutionStateAskForBidRejected', 'ExecutionStateBidAccepted', 'ExecutionStateBidRejected', 'ExecutionStateCompleted', 'ExecutionStateFailed', 'ExecutionStateCancelled']
} as const;

export const models_FailureInjectionRequesterConfigSchema = {
    type: 'object',
    properties: {
        isBadActor: {
            type: 'boolean'
        }
    }
} as const;

export const models_GPUSchema = {
    type: 'object',
    properties: {
        index: {
            description: 'Self-reported index of the device in the system',
            type: 'integer'
        },
        memory: {
            description: 'Total GPU memory in mebibytes (MiB)',
            type: 'integer'
        },
        name: {
            description: 'Model name of the GPU e.g. Tesla T4',
            type: 'string'
        },
        pciaddress: {
            description: `PCI address of the device, in the format AAAA:BB:CC.C
Used to discover the correct device rendering cards`,
            type: 'string'
        },
        vendor: {
            description: 'Maker of the GPU, e.g. NVidia, AMD, Intel',
            allOf: [
                {
                    '$ref': '#/definitions/models.GPUVendor'
                }
            ]
        }
    }
} as const;

export const models_GPUVendorSchema = {
    type: 'string',
    enum: ['NVIDIA', 'AMD/ATI', 'Intel'],
    'x-enum-varnames': ['GPUVendorNvidia', 'GPUVendorAMDATI', 'GPUVendorIntel']
} as const;

export const models_InputSourceSchema = {
    type: 'object',
    properties: {
        Alias: {
            description: `Alias is an optional reference to this input source that can be used for
dynamic linking to this input. (e.g. dynamic import in wasm by alias)`,
            type: 'string'
        },
        Source: {
            description: 'Source is the source of the artifact to be downloaded, e.g a URL, S3 bucket, etc.',
            allOf: [
                {
                    '$ref': '#/definitions/models.SpecConfig'
                }
            ]
        },
        Target: {
            description: 'Target is the path where the artifact should be mounted on',
            type: 'string'
        }
    }
} as const;

export const models_JobSchema = {
    type: 'object',
    properties: {
        Constraints: {
            description: 'Constraints is a selector which must be true for the compute node to run this job.',
            type: 'array',
            items: {
                '$ref': '#/definitions/models.LabelSelectorRequirement'
            }
        },
        Count: {
            description: 'Count is the number of replicas that should be scheduled.',
            type: 'integer'
        },
        CreateTime: {
            type: 'integer'
        },
        ID: {
            description: `ID is a unique identifier assigned to this job.
It helps to distinguish jobs with the same name after they have been deleted and re-created.
The ID is generated by the server and should not be set directly by the client.`,
            type: 'string'
        },
        Labels: {
            description: `Labels is used to associate arbitrary labels with this job, which can be used
for filtering.
key=value`,
            type: 'object',
            additionalProperties: {
                type: 'string'
            }
        },
        Meta: {
            description: 'Meta is used to associate arbitrary metadata with this job.',
            type: 'object',
            additionalProperties: {
                type: 'string'
            }
        },
        ModifyTime: {
            type: 'integer'
        },
        Name: {
            description: `Name is the logical name of the job used to refer to it.
Submitting a job with the same name as an existing job will result in an
update to the existing job.`,
            type: 'string'
        },
        Namespace: {
            description: 'Namespace is the namespace this job is running in.',
            type: 'string'
        },
        Priority: {
            description: 'Priority defines the scheduling priority of this job.',
            type: 'integer'
        },
        Revision: {
            description: `Revision is a per-job monotonically increasing revision number that is incremented
on each update to the job's state or specification`,
            type: 'integer'
        },
        State: {
            description: 'State is the current state of the job.',
            allOf: [
                {
                    '$ref': '#/definitions/models.State-models_JobStateType'
                }
            ]
        },
        Tasks: {
            type: 'array',
            items: {
                '$ref': '#/definitions/models.Task'
            }
        },
        Type: {
            description: 'Type is the type of job this is, e.g. "daemon" or "batch".',
            type: 'string'
        },
        Version: {
            description: `Version is a per-job monotonically increasing version number that is incremented
on each job specification update.`,
            type: 'integer'
        }
    }
} as const;

export const models_JobHistorySchema = {
    type: 'object',
    properties: {
        Event: {
            '$ref': '#/definitions/models.Event'
        },
        ExecutionID: {
            type: 'string'
        },
        ExecutionState: {
            description: 'Deprecated: Left for backward compatibility with v1.4.x clients',
            allOf: [
                {
                    '$ref': '#/definitions/models.StateChange-models_ExecutionStateType'
                }
            ]
        },
        JobID: {
            type: 'string'
        },
        JobState: {
            description: `TODO: remove with v1.5
Deprecated: Left for backward compatibility with v1.4.x clients`,
            allOf: [
                {
                    '$ref': '#/definitions/models.StateChange-models_JobStateType'
                }
            ]
        },
        Time: {
            type: 'string'
        },
        Type: {
            '$ref': '#/definitions/models.JobHistoryType'
        }
    }
} as const;

export const models_JobHistoryTypeSchema = {
    type: 'integer',
    enum: [0, 1, 2],
    'x-enum-varnames': ['JobHistoryTypeUndefined', 'JobHistoryTypeJobLevel', 'JobHistoryTypeExecutionLevel']
} as const;

export const models_JobSelectionDataLocalitySchema = {
    type: 'integer',
    enum: [0, 1],
    'x-enum-comments': {
        Anywhere: 'anywhere',
        Local: 'local'
    },
    'x-enum-varnames': ['Local', 'Anywhere']
} as const;

export const models_JobSelectionPolicySchema = {
    type: 'object',
    properties: {
        accept_networked_jobs: {
            description: `should we accept jobs that specify networking
the default is "reject"`,
            type: 'boolean'
        },
        locality: {
            description: `this describes if we should run a job based on
where the data is located - i.e. if the data is "local"
or if the data is "anywhere"`,
            allOf: [
                {
                    '$ref': '#/definitions/models.JobSelectionDataLocality'
                }
            ]
        },
        probe_exec: {
            type: 'string'
        },
        probe_http: {
            description: `external hooks that decide if we should take on the job or not
if either of these are given they will override the data locality settings`,
            type: 'string'
        },
        reject_stateless_jobs: {
            description: `should we reject jobs that don't specify any data
the default is "accept"`,
            type: 'boolean'
        }
    }
} as const;

export const models_JobStateTypeSchema = {
    type: 'integer',
    enum: [0, 1, 2, 3, 4, 5, 6],
    'x-enum-varnames': ['JobStateTypeUndefined', 'JobStateTypePending', 'JobStateTypeQueued', 'JobStateTypeRunning', 'JobStateTypeCompleted', 'JobStateTypeFailed', 'JobStateTypeStopped']
} as const;

export const models_LabelSelectorRequirementSchema = {
    type: 'object',
    properties: {
        Key: {
            description: 'key is the label key that the selector applies to.',
            type: 'string'
        },
        Operator: {
            description: `operator represents a key's relationship to a set of values.
Valid operators are In, NotIn, Exists and KeyNotInImap.`,
            allOf: [
                {
                    '$ref': '#/definitions/selection.Operator'
                }
            ]
        },
        Values: {
            description: `values is an array of string values. If the operator is In or NotIn,
the values array must be non-empty. If the operator is Exists or KeyNotInImap,
the values array must be empty. This array is replaced during a strategic`,
            type: 'array',
            items: {
                type: 'string'
            }
        }
    }
} as const;

export const models_NetworkSchema = {
    type: 'integer',
    enum: [0, 1, 2],
    'x-enum-varnames': ['NetworkNone', 'NetworkFull', 'NetworkHTTP']
} as const;

export const models_NetworkConfigSchema = {
    type: 'object',
    properties: {
        Domains: {
            type: 'array',
            items: {
                type: 'string'
            }
        },
        Type: {
            '$ref': '#/definitions/models.Network'
        }
    }
} as const;

export const models_NodeConnectionStateSchema = {
    type: 'object',
    properties: {
        connection: {
            type: 'integer',
            enum: [0, 1],
            'x-enum-varnames': ['connected', 'disconnected']
        }
    }
} as const;

export const models_NodeInfoSchema = {
    type: 'object',
    properties: {
        BacalhauVersion: {
            '$ref': '#/definitions/models.BuildVersionInfo'
        },
        ComputeNodeInfo: {
            '$ref': '#/definitions/models.ComputeNodeInfo'
        },
        Labels: {
            type: 'object',
            additionalProperties: {
                type: 'string'
            }
        },
        NodeID: {
            description: 'TODO replace all access on this field with the `ID()` method',
            type: 'string'
        },
        NodeType: {
            '$ref': '#/definitions/models.NodeType'
        }
    }
} as const;

export const models_NodeMembershipStateSchema = {
    type: 'object',
    properties: {
        membership: {
            type: 'integer',
            enum: [0, 1, 2, 3],
            'x-enum-varnames': ['unknown', 'pending', 'approved', 'rejected']
        }
    }
} as const;

export const models_NodeStateSchema = {
    type: 'object',
    properties: {
        Connection: {
            '$ref': '#/definitions/models.NodeConnectionState'
        },
        Info: {
            '$ref': '#/definitions/models.NodeInfo'
        },
        Membership: {
            '$ref': '#/definitions/models.NodeMembershipState'
        }
    }
} as const;

export const models_NodeTypeSchema = {
    type: 'integer',
    enum: [0, 1, 2],
    'x-enum-varnames': ['nodeTypeUndefined', 'NodeTypeRequester', 'NodeTypeCompute']
} as const;

export const models_ResourcesSchema = {
    type: 'object',
    properties: {
        CPU: {
            description: 'CPU units',
            type: 'number'
        },
        Disk: {
            description: 'Disk in bytes',
            type: 'integer'
        },
        GPU: {
            description: 'GPU units',
            type: 'integer'
        },
        GPUs: {
            description: 'GPU details',
            type: 'array',
            items: {
                '$ref': '#/definitions/models.GPU'
            }
        },
        Memory: {
            description: 'Memory in bytes',
            type: 'integer'
        }
    }
} as const;

export const models_ResourcesConfigSchema = {
    type: 'object',
    properties: {
        CPU: {
            description: 'CPU https://github.com/BTBurke/k8sresource string',
            type: 'string'
        },
        Disk: {
            description: 'Memory github.com/dustin/go-humanize string',
            type: 'string'
        },
        GPU: {
            type: 'string'
        },
        Memory: {
            description: 'Memory github.com/dustin/go-humanize string',
            type: 'string'
        }
    }
} as const;

export const models_ResultPathSchema = {
    type: 'object',
    properties: {
        Name: {
            description: 'Name',
            type: 'string'
        },
        Path: {
            description: 'The path to the file/dir',
            type: 'string'
        }
    }
} as const;

export const models_RunCommandResultSchema = {
    type: 'object',
    properties: {
        ErrorMsg: {
            description: 'Runner error',
            type: 'string'
        },
        ExitCode: {
            description: 'exit code of the run.',
            type: 'integer'
        },
        StderrTruncated: {
            description: 'bool describing if stderr was truncated',
            type: 'boolean'
        },
        Stdout: {
            description: 'stdout of the run. Yaml provided for `describe` output',
            type: 'string'
        },
        StdoutTruncated: {
            description: 'bool describing if stdout was truncated',
            type: 'boolean'
        },
        stderr: {
            description: 'stderr of the run.',
            type: 'string'
        }
    }
} as const;

export const models_SpecConfigSchema = {
    type: 'object',
    properties: {
        Params: {
            description: 'Params is a map of the config params',
            type: 'object',
            additionalProperties: true
        },
        Type: {
            description: 'Type of the config',
            type: 'string'
        }
    }
} as const;

export const models_State_models_ExecutionDesiredStateTypeSchema = {
    type: 'object',
    properties: {
        Message: {
            description: 'Message is a human readable message describing the state.',
            type: 'string'
        },
        StateType: {
            description: 'StateType is the current state of the object.',
            allOf: [
                {
                    '$ref': '#/definitions/models.ExecutionDesiredStateType'
                }
            ]
        }
    }
} as const;

export const models_State_models_ExecutionStateTypeSchema = {
    type: 'object',
    properties: {
        Message: {
            description: 'Message is a human readable message describing the state.',
            type: 'string'
        },
        StateType: {
            description: 'StateType is the current state of the object.',
            allOf: [
                {
                    '$ref': '#/definitions/models.ExecutionStateType'
                }
            ]
        }
    }
} as const;

export const models_State_models_JobStateTypeSchema = {
    type: 'object',
    properties: {
        Message: {
            description: 'Message is a human readable message describing the state.',
            type: 'string'
        },
        StateType: {
            description: 'StateType is the current state of the object.',
            allOf: [
                {
                    '$ref': '#/definitions/models.JobStateType'
                }
            ]
        }
    }
} as const;

export const models_StateChange_models_ExecutionStateTypeSchema = {
    type: 'object',
    properties: {
        New: {
            '$ref': '#/definitions/models.ExecutionStateType'
        },
        Previous: {
            '$ref': '#/definitions/models.ExecutionStateType'
        }
    }
} as const;

export const models_StateChange_models_JobStateTypeSchema = {
    type: 'object',
    properties: {
        New: {
            '$ref': '#/definitions/models.JobStateType'
        },
        Previous: {
            '$ref': '#/definitions/models.JobStateType'
        }
    }
} as const;

export const models_TaskSchema = {
    type: 'object',
    properties: {
        Engine: {
            '$ref': '#/definitions/models.SpecConfig'
        },
        Env: {
            description: 'Map of environment variables to be used by the driver',
            type: 'object',
            additionalProperties: {
                type: 'string'
            }
        },
        InputSources: {
            description: `InputSources is a list of remote artifacts to be downloaded before running the task
and mounted into the task.`,
            type: 'array',
            items: {
                '$ref': '#/definitions/models.InputSource'
            }
        },
        Meta: {
            description: 'Meta is used to associate arbitrary metadata with this task.',
            type: 'object',
            additionalProperties: {
                type: 'string'
            }
        },
        Name: {
            description: 'Name of the task',
            type: 'string'
        },
        Network: {
            '$ref': '#/definitions/models.NetworkConfig'
        },
        Publisher: {
            '$ref': '#/definitions/models.SpecConfig'
        },
        Resources: {
            description: 'ResourcesConfig is the resources needed by this task',
            allOf: [
                {
                    '$ref': '#/definitions/models.ResourcesConfig'
                }
            ]
        },
        ResultPaths: {
            description: "ResultPaths is a list of task volumes to be included in the task's published result",
            type: 'array',
            items: {
                '$ref': '#/definitions/models.ResultPath'
            }
        },
        Timeouts: {
            '$ref': '#/definitions/models.TimeoutConfig'
        }
    }
} as const;

export const models_TimeoutConfigSchema = {
    type: 'object',
    properties: {
        ExecutionTimeout: {
            description: `ExecutionTimeout is the maximum amount of time a task is allowed to run in seconds.
Zero means no timeout, such as for a daemon task.`,
            type: 'integer'
        },
        QueueTimeout: {
            description: `QueueTimeout is the maximum amount of time a task is allowed to wait in the orchestrator
queue in seconds before being scheduled. Zero means no timeout.`,
            type: 'integer'
        },
        TotalTimeout: {
            description: `TotalTimeout is the maximum amount of time a task is allowed to complete in seconds.
This includes the time spent in the queue, the time spent executing and the time spent retrying.
Zero means no timeout.`,
            type: 'integer'
        }
    }
} as const;

export const selection_OperatorSchema = {
    type: 'string',
    enum: ['!', '=', '==', 'in', '!=', 'notin', 'exists', 'gt', 'lt'],
    'x-enum-varnames': ['DoesNotExist', 'Equals', 'DoubleEquals', 'In', 'NotEquals', 'NotIn', 'Exists', 'GreaterThan', 'LessThan']
} as const;

export const shared_VersionRequestSchema = {
    type: 'object',
    properties: {
        client_id: {
            type: 'string',
            example: 'ac13188e93c97a9c2e7cf8e86c7313156a73436036f30da1ececc2ce79f9ea51'
        }
    }
} as const;

export const shared_VersionResponseSchema = {
    type: 'object',
    properties: {
        build_version_info: {
            '$ref': '#/definitions/models.BuildVersionInfo'
        }
    }
} as const;

export const types_APIConfigSchema = {
    type: 'object',
    properties: {
        clientTLS: {
            description: `ClientTLS specifies tls options for the client connecting to the
API.`,
            allOf: [
                {
                    '$ref': '#/definitions/types.ClientTLSConfig'
                }
            ]
        },
        host: {
            description: "Host is the hostname of an environment's public API servers.",
            type: 'string'
        },
        port: {
            description: 'Port is the port that an environment serves the public API on.',
            type: 'integer'
        },
        tls: {
            description: `TLS returns information about how TLS is configured for the public server.
This is only used in APIConfig for NodeConfig.ServerAPI`,
            allOf: [
                {
                    '$ref': '#/definitions/types.TLSConfiguration'
                }
            ]
        }
    }
} as const;

export const types_AuthConfigSchema = {
    type: 'object',
    properties: {
        accessPolicyPath: {
            description: `AccessPolicyPath is the path to a file or directory that will be loaded as
the policy to apply to all inbound API requests. If unspecified, a policy
that permits access to all API endpoints to both authenticated and
unauthenticated users (the default as of v1.2.0) will be used.`,
            type: 'string'
        },
        methods: {
            description: `Methods maps "method names" to authenticator implementations. A method
name is a human-readable string chosen by the person configuring the
system that is shown to users to help them pick the authentication method
they want to use. There can be multiple usages of the same Authenticator
*type* but with different configs and parameters, each identified with a
unique method name.

For example, if an implementation wants to allow users to log in with
Github or Bitbucket, they might both use an authenticator implementation
of type "oidc", and each would appear once on this provider with key /
method name "github" and "bitbucket".

By default, only a single authentication method that accepts
authentication via client keys will be enabled.`,
            type: 'object',
            additionalProperties: {
                '$ref': '#/definitions/types.AuthenticatorConfig'
            }
        },
        tokensPath: {
            description: `TokensPath is the location where a state file of tokens will be stored.
By default it will be local to the Bacalhau repo, but can be any location
in the host filesystem. Tokens are sensitive and should be stored in a
location that is only readable to the current user.
Deprecated: replaced by cfg.AuthTokensPath()`,
            type: 'string'
        }
    }
} as const;

export const types_AuthenticatorConfigSchema = {
    type: 'object',
    properties: {
        policyPath: {
            type: 'string'
        },
        type: {
            '$ref': '#/definitions/authn.MethodType'
        }
    }
} as const;

export const types_BacalhauConfigSchema = {
    type: 'object',
    properties: {
        auth: {
            '$ref': '#/definitions/types.AuthConfig'
        },
        dataDir: {
            description: "NB(forrest): this field shouldn't be persisted yet.",
            type: 'string'
        },
        metrics: {
            '$ref': '#/definitions/types.MetricsConfig'
        },
        node: {
            '$ref': '#/definitions/types.NodeConfig'
        },
        update: {
            '$ref': '#/definitions/types.UpdateConfig'
        },
        user: {
            '$ref': '#/definitions/types.UserConfig'
        }
    }
} as const;

export const types_CapacityConfigSchema = {
    type: 'object',
    properties: {
        defaultJobResourceLimits: {
            '$ref': '#/definitions/models.ResourcesConfig'
        },
        ignorePhysicalResourceLimits: {
            type: 'boolean'
        },
        jobResourceLimits: {
            description: 'Per job amount of resource the system can be using at one time.',
            allOf: [
                {
                    '$ref': '#/definitions/models.ResourcesConfig'
                }
            ]
        },
        totalResourceLimits: {
            description: 'Total amount of resource the system can be using at one time in aggregate for all jobs.',
            allOf: [
                {
                    '$ref': '#/definitions/models.ResourcesConfig'
                }
            ]
        }
    }
} as const;

export const types_ClientTLSConfigSchema = {
    type: 'object',
    properties: {
        cacert: {
            description: `Used for NodeConfig.ClientAPI, specifies the location of a ca certificate
file (primarily for self-signed server certs). Will use HTTPS for requests.`,
            type: 'string'
        },
        insecure: {
            description: `Used for NodeConfig.ClientAPI, and when true instructs the client to use
HTTPS, but not to attempt to verify the certificate.`,
            type: 'boolean'
        },
        useTLS: {
            description: `Used for NodeConfig.ClientAPI, instructs the client to connect over
TLS.  Auto enabled if Insecure or CACert are specified.`,
            type: 'boolean'
        }
    }
} as const;

export const types_ComputeConfigSchema = {
    type: 'object',
    properties: {
        capacity: {
            '$ref': '#/definitions/types.CapacityConfig'
        },
        controlPlaneSettings: {
            '$ref': '#/definitions/types.ComputeControlPlaneConfig'
        },
        executionStore: {
            '$ref': '#/definitions/types.JobStoreConfig'
        },
        jobSelection: {
            '$ref': '#/definitions/models.JobSelectionPolicy'
        },
        jobTimeouts: {
            '$ref': '#/definitions/types.JobTimeoutConfig'
        },
        localPublisher: {
            '$ref': '#/definitions/types.LocalPublisherConfig'
        },
        logStreamConfig: {
            '$ref': '#/definitions/types.LogStreamConfig'
        },
        logging: {
            '$ref': '#/definitions/types.LoggingConfig'
        },
        manifestCache: {
            '$ref': '#/definitions/types.DockerCacheConfig'
        }
    }
} as const;

export const types_ComputeControlPlaneConfigSchema = {
    type: 'object',
    properties: {
        heartbeatFrequency: {
            description: `How often the compute node will send a heartbeat to the requester node to let it know
that the compute node is still alive. This should be less than the requester's configured
heartbeat timeout to avoid flapping.`,
            allOf: [
                {
                    '$ref': '#/definitions/types.Duration'
                }
            ]
        },
        heartbeatTopic: {
            description: 'This is the pubsub topic that the compute node will use to send heartbeats to the requester node.',
            type: 'string'
        },
        infoUpdateFrequency: {
            description: `The frequency with which the compute node will send node info (inc current labels)
to the controlling requester node.`,
            allOf: [
                {
                    '$ref': '#/definitions/types.Duration'
                }
            ]
        },
        resourceUpdateFrequency: {
            description: 'How often the compute node will send current resource availability to the requester node.',
            allOf: [
                {
                    '$ref': '#/definitions/types.Duration'
                }
            ]
        }
    }
} as const;

export const types_DockerCacheConfigSchema = {
    type: 'object',
    properties: {
        duration: {
            '$ref': '#/definitions/types.Duration'
        },
        frequency: {
            '$ref': '#/definitions/types.Duration'
        },
        size: {
            type: 'integer'
        }
    }
} as const;

export const types_DurationSchema = {
    type: 'integer',
    enum: [-9223372036854776000, 9223372036854776000, 1, 1000, 1000000, 1000000000, 60000000000, 3600000000000],
    'x-enum-varnames': ['minDuration', 'maxDuration', 'Nanosecond', 'Microsecond', 'Millisecond', 'Second', 'Minute', 'Hour']
} as const;

export const types_EvaluationBrokerConfigSchema = {
    type: 'object',
    properties: {
        evalBrokerInitialRetryDelay: {
            '$ref': '#/definitions/types.Duration'
        },
        evalBrokerMaxRetryCount: {
            type: 'integer'
        },
        evalBrokerSubsequentRetryDelay: {
            '$ref': '#/definitions/types.Duration'
        },
        evalBrokerVisibilityTimeout: {
            '$ref': '#/definitions/types.Duration'
        }
    }
} as const;

export const types_FeatureConfigSchema = {
    type: 'object',
    properties: {
        engines: {
            type: 'array',
            items: {
                type: 'string'
            }
        },
        publishers: {
            type: 'array',
            items: {
                type: 'string'
            }
        },
        storages: {
            type: 'array',
            items: {
                type: 'string'
            }
        }
    }
} as const;

export const types_FreeSpaceSchema = {
    type: 'object',
    properties: {
        root: {
            '$ref': '#/definitions/types.MountStatus'
        },
        tmp: {
            '$ref': '#/definitions/types.MountStatus'
        }
    }
} as const;

export const types_HealthInfoSchema = {
    type: 'object',
    properties: {
        FreeSpace: {
            '$ref': '#/definitions/types.FreeSpace'
        }
    }
} as const;

export const types_IpfsConfigSchema = {
    type: 'object',
    properties: {
        connect: {
            description: 'Connect is the multiaddress to connect to for IPFS.',
            type: 'string'
        }
    }
} as const;

export const types_JobDefaultsSchema = {
    type: 'object',
    properties: {
        executionTimeout: {
            '$ref': '#/definitions/types.Duration'
        },
        queueTimeout: {
            '$ref': '#/definitions/types.Duration'
        },
        totalTimeout: {
            '$ref': '#/definitions/types.Duration'
        }
    }
} as const;

export const types_JobStoreConfigSchema = {
    type: 'object',
    properties: {
        path: {
            type: 'string'
        },
        type: {
            '$ref': '#/definitions/types.StorageType'
        }
    }
} as const;

export const types_JobTimeoutConfigSchema = {
    type: 'object',
    properties: {
        defaultJobExecutionTimeout: {
            description: `DefaultJobExecutionTimeout default value for the execution timeout this compute node will assign to jobs with
no timeout requirement defined.`,
            allOf: [
                {
                    '$ref': '#/definitions/types.Duration'
                }
            ]
        },
        jobExecutionTimeoutClientIDBypassList: {
            description: `JobExecutionTimeoutClientIDBypassList is the list of clients that are allowed to bypass the job execution timeout
check.`,
            type: 'array',
            items: {
                type: 'string'
            }
        },
        jobNegotiationTimeout: {
            description: 'JobNegotiationTimeout default timeout value to hold a bid for a job',
            allOf: [
                {
                    '$ref': '#/definitions/types.Duration'
                }
            ]
        },
        maxJobExecutionTimeout: {
            description: `MaxJobExecutionTimeout default value for the maximum execution timeout this compute node supports. Jobs with
higher timeout requirements will not be bid on.`,
            allOf: [
                {
                    '$ref': '#/definitions/types.Duration'
                }
            ]
        },
        minJobExecutionTimeout: {
            description: `MinJobExecutionTimeout default value for the minimum execution timeout this compute node supports. Jobs with
lower timeout requirements will not be bid on.`,
            allOf: [
                {
                    '$ref': '#/definitions/types.Duration'
                }
            ]
        }
    }
} as const;

export const types_LocalPublisherConfigSchema = {
    type: 'object',
    properties: {
        address: {
            type: 'string'
        },
        directory: {
            type: 'string'
        },
        port: {
            type: 'integer'
        }
    }
} as const;

export const types_LogStreamConfigSchema = {
    type: 'object',
    properties: {
        channelBufferSize: {
            description: 'How many messages to buffer in the log stream channel, per stream',
            type: 'integer'
        }
    }
} as const;

export const types_LoggingConfigSchema = {
    type: 'object',
    properties: {
        logRunningExecutionsInterval: {
            description: 'logging running executions',
            allOf: [
                {
                    '$ref': '#/definitions/types.Duration'
                }
            ]
        }
    }
} as const;

export const types_MetricsConfigSchema = {
    type: 'object',
    properties: {
        eventTracerPath: {
            type: 'string'
        }
    }
} as const;

export const types_MountStatusSchema = {
    type: 'object',
    properties: {
        All: {
            type: 'integer'
        },
        Free: {
            type: 'integer'
        },
        Used: {
            type: 'integer'
        }
    }
} as const;

export const types_NetworkClusterConfigSchema = {
    type: 'object',
    properties: {
        advertisedAddress: {
            type: 'string'
        },
        name: {
            type: 'string'
        },
        peers: {
            type: 'array',
            items: {
                type: 'string'
            }
        },
        port: {
            type: 'integer'
        }
    }
} as const;

export const types_NetworkConfigSchema = {
    type: 'object',
    properties: {
        advertisedAddress: {
            type: 'string'
        },
        authSecret: {
            type: 'string'
        },
        cluster: {
            '$ref': '#/definitions/types.NetworkClusterConfig'
        },
        orchestrators: {
            type: 'array',
            items: {
                type: 'string'
            }
        },
        port: {
            type: 'integer'
        },
        storeDir: {
            type: 'string'
        }
    }
} as const;

export const types_NodeConfigSchema = {
    type: 'object',
    properties: {
        allowListedLocalPaths: {
            description: 'AllowListedLocalPaths contains local paths that are allowed to be mounted into jobs',
            type: 'array',
            items: {
                type: 'string'
            }
        },
        clientAPI: {
            '$ref': '#/definitions/types.APIConfig'
        },
        compute: {
            '$ref': '#/definitions/types.ComputeConfig'
        },
        computeStoragePath: {
            description: `TODO(forrest) [refactor]: rename this to ExecutorStoragePath
Deprecated: replaced by cfg.ComputeDir()`,
            type: 'string'
        },
        disabledFeatures: {
            description: 'What features should not be enabled even if installed',
            allOf: [
                {
                    '$ref': '#/definitions/types.FeatureConfig'
                }
            ]
        },
        downloadURLRequestRetries: {
            type: 'integer'
        },
        downloadURLRequestTimeout: {
            '$ref': '#/definitions/types.Duration'
        },
        executorPluginPath: {
            description: 'Deprecated: replaced by cfg.PluginsDir()',
            type: 'string'
        },
        ipfs: {
            '$ref': '#/definitions/types.IpfsConfig'
        },
        labels: {
            description: 'Labels to apply to the node that can be used for node selection and filtering',
            type: 'object',
            additionalProperties: {
                type: 'string'
            }
        },
        loggingMode: {
            '$ref': '#/definitions/logger.LogMode'
        },
        name: {
            type: 'string'
        },
        nameProvider: {
            type: 'string'
        },
        network: {
            '$ref': '#/definitions/types.NetworkConfig'
        },
        requester: {
            '$ref': '#/definitions/types.RequesterConfig'
        },
        serverAPI: {
            '$ref': '#/definitions/types.APIConfig'
        },
        strictVersionMatch: {
            type: 'boolean'
        },
        type: {
            description: 'Type is "compute", "requester" or both',
            type: 'array',
            items: {
                type: 'string'
            }
        },
        volumeSizeRequestTimeout: {
            '$ref': '#/definitions/types.Duration'
        },
        webUI: {
            description: 'Configuration for the web UI',
            allOf: [
                {
                    '$ref': '#/definitions/types.WebUIConfig'
                }
            ]
        }
    }
} as const;

export const types_RequesterConfigSchema = {
    type: 'object',
    properties: {
        controlPlaneSettings: {
            '$ref': '#/definitions/types.RequesterControlPlaneConfig'
        },
        defaultPublisher: {
            type: 'string'
        },
        evaluationBroker: {
            '$ref': '#/definitions/types.EvaluationBrokerConfig'
        },
        externalVerifierHook: {
            description: 'URL where to send external verification requests to.',
            type: 'string'
        },
        failureInjectionConfig: {
            '$ref': '#/definitions/models.FailureInjectionRequesterConfig'
        },
        housekeepingBackgroundTaskInterval: {
            '$ref': '#/definitions/types.Duration'
        },
        jobDefaults: {
            '$ref': '#/definitions/types.JobDefaults'
        },
        jobSelectionPolicy: {
            description: 'How the node decides what jobs to run.',
            allOf: [
                {
                    '$ref': '#/definitions/models.JobSelectionPolicy'
                }
            ]
        },
        jobStore: {
            '$ref': '#/definitions/types.JobStoreConfig'
        },
        manualNodeApproval: {
            description: `ManualNodeApproval is a flag that determines if nodes should be manually approved or not.
By default, nodes are auto-approved to simplify upgrades, by setting this property to
true, nodes will need to be manually approved before they are included in node selection.`,
            type: 'boolean'
        },
        nodeInfoStoreTTL: {
            '$ref': '#/definitions/types.Duration'
        },
        nodeRankRandomnessRange: {
            type: 'integer'
        },
        overAskForBidsFactor: {
            type: 'integer'
        },
        scheduler: {
            '$ref': '#/definitions/types.SchedulerConfig'
        },
        storageProvider: {
            '$ref': '#/definitions/types.StorageProviderConfig'
        },
        tagCache: {
            '$ref': '#/definitions/types.DockerCacheConfig'
        },
        translationEnabled: {
            type: 'boolean'
        },
        worker: {
            '$ref': '#/definitions/types.WorkerConfig'
        }
    }
} as const;

export const types_RequesterControlPlaneConfigSchema = {
    type: 'object',
    properties: {
        heartbeatCheckFrequency: {
            description: `This setting is the time period after which a compute node is considered to be unresponsive.
If the compute node misses two of these frequencies, it will be marked as unknown.  The compute
node should have a frequency setting less than this one to ensure that it does not keep
switching between unknown and active too frequently.`,
            allOf: [
                {
                    '$ref': '#/definitions/types.Duration'
                }
            ]
        },
        heartbeatTopic: {
            description: 'This is the pubsub topic that the compute node will use to send heartbeats to the requester node.',
            type: 'string'
        },
        nodeDisconnectedAfter: {
            description: `This is the time period after which a compute node is considered to be disconnected. If the compute
node does not deliver a heartbeat every \`NodeDisconnectedAfter\` then it is considered disconnected.`,
            allOf: [
                {
                    '$ref': '#/definitions/types.Duration'
                }
            ]
        }
    }
} as const;

export const types_S3StorageProviderConfigSchema = {
    type: 'object',
    properties: {
        preSignedURLDisabled: {
            type: 'boolean'
        },
        preSignedURLExpiration: {
            '$ref': '#/definitions/types.Duration'
        }
    }
} as const;

export const types_SchedulerConfigSchema = {
    type: 'object',
    properties: {
        nodeOverSubscriptionFactor: {
            type: 'number'
        },
        queueBackoff: {
            '$ref': '#/definitions/types.Duration'
        }
    }
} as const;

export const types_StorageProviderConfigSchema = {
    type: 'object',
    properties: {
        s3: {
            '$ref': '#/definitions/types.S3StorageProviderConfig'
        }
    }
} as const;

export const types_StorageTypeSchema = {
    type: 'integer',
    enum: [0, 1],
    'x-enum-varnames': ['UnknownStorage', 'BoltDB']
} as const;

export const types_TLSConfigurationSchema = {
    type: 'object',
    properties: {
        autoCert: {
            description: `AutoCert specifies a hostname for a certificate to be obtained via ACME.
This is only used by the server, and only by the requester node when it
has a publicly resolvable domain name.`,
            type: 'string'
        },
        autoCertCachePath: {
            description: `AutoCertCachePath specifies the directory where the autocert process
will cache certificates to avoid rate limits.`,
            type: 'string'
        },
        selfSigned: {
            description: `SelfSignedCert will auto-generate a self-signed certificate for the
requester node if TLS certificates have not been provided.`,
            type: 'boolean'
        },
        serverCertificate: {
            description: `ServerCertificate specifies the location of a TLS certificate to be used
by the requester to serve TLS requests`,
            type: 'string'
        },
        serverKey: {
            description: `ServerKey is the TLS server key to match the certificate to allow the
requester to server TLS.`,
            type: 'string'
        }
    }
} as const;

export const types_UpdateConfigSchema = {
    type: 'object',
    properties: {
        checkFrequency: {
            '$ref': '#/definitions/types.Duration'
        },
        skipChecks: {
            type: 'boolean'
        }
    }
} as const;

export const types_UserConfigSchema = {
    type: 'object',
    properties: {
        installationID: {
            type: 'string'
        },
        keyPath: {
            description: `KeyPath is deprecated
Deprecated: replaced by cfg.UserKeyPath()`,
            type: 'string'
        }
    }
} as const;

export const types_WebUIConfigSchema = {
    type: 'object',
    properties: {
        enabled: {
            type: 'boolean'
        },
        port: {
            type: 'integer'
        }
    }
} as const;

export const types_WorkerConfigSchema = {
    type: 'object',
    properties: {
        workerCount: {
            type: 'integer'
        },
        workerEvalDequeueBaseBackoff: {
            '$ref': '#/definitions/types.Duration'
        },
        workerEvalDequeueMaxBackoff: {
            '$ref': '#/definitions/types.Duration'
        },
        workerEvalDequeueTimeout: {
            '$ref': '#/definitions/types.Duration'
        }
    }
} as const;