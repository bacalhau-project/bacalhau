// This file is auto-generated by @hey-api/openapi-ts

export type apimodels_GetJobResponse = {
    Executions?: apimodels_ListJobExecutionsResponse;
    History?: apimodels_ListJobHistoryResponse;
    Job?: models_Job;
};

export type apimodels_GetNodeResponse = {
    node?: models_NodeState;
};

export type apimodels_GetVersionResponse = {
    BuildDate?: string;
    GOARCH?: string;
    GOOS?: string;
    GitCommit?: string;
    GitVersion?: string;
    Major?: string;
    Minor?: string;
};

export type apimodels_HTTPCredential = {
    /**
     * For authorization schemes that provide multiple values, a map of names to
     * values providing the credential
     */
    params?: {
        [key: string]: (string);
    };
    /**
     * An HTTP authorization scheme, such as one registered with IANA
     * https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml
     */
    scheme?: string;
    /**
     * For authorization schemes that only provide a single value, such as
     * Basic, the single string value providing the credential
     */
    value?: string;
};

export type apimodels_ListJobExecutionsResponse = {
    Items?: Array<models_Execution>;
    NextToken?: string;
};

export type apimodels_ListJobHistoryResponse = {
    Items?: Array<models_JobHistory>;
    NextToken?: string;
};

export type apimodels_ListJobResultsResponse = {
    Items?: Array<models_SpecConfig>;
    NextToken?: string;
};

export type apimodels_ListJobsResponse = {
    Items?: Array<models_Job>;
    NextToken?: string;
};

export type apimodels_ListNodesResponse = {
    NextToken?: string;
    nodes?: Array<models_NodeState>;
};

export type apimodels_PutJobRequest = {
    Job?: models_Job;
    credential?: apimodels_HTTPCredential;
    idempotencyToken?: string;
    namespace?: string;
};

export type apimodels_PutJobResponse = {
    EvaluationID?: string;
    JobID?: string;
    Warnings?: Array<(string)>;
};

export type apimodels_PutNodeRequest = {
    action?: string;
    credential?: apimodels_HTTPCredential;
    idempotencyToken?: string;
    message?: string;
    namespace?: string;
    nodeID?: string;
};

export type apimodels_PutNodeResponse = {
    error?: string;
    success?: boolean;
};

export type apimodels_StopJobResponse = {
    EvaluationID?: string;
};

export type authn_MethodType = 'challenge' | 'ask';

export type logger_LogMode = 'default' | 'station' | 'json' | 'combined' | 'event';

export type models_AllocatedResources = {
    Tasks?: {
        [key: string]: models_Resources;
    };
};

export type models_BuildVersionInfo = {
    BuildDate?: string;
    GOARCH?: string;
    GOOS?: string;
    GitCommit?: string;
    GitVersion?: string;
    Major?: string;
    Minor?: string;
};

export type models_ComputeNodeInfo = {
    AvailableCapacity?: models_Resources;
    EnqueuedExecutions?: number;
    ExecutionEngines?: Array<(string)>;
    MaxCapacity?: models_Resources;
    MaxJobRequirements?: models_Resources;
    Publishers?: Array<(string)>;
    QueueCapacity?: models_Resources;
    RunningExecutions?: number;
    StorageSources?: Array<(string)>;
};

export type models_DebugInfo = {
    component?: string;
    info?: unknown;
};

export type models_Event = {
    /**
     * Any additional metadata that the system or user may need to know about
     * the event in order to handle it properly.
     */
    Details?: {
        [key: string]: (string);
    };
    /**
     * A human-readable string giving the user all the information they need to
     * understand and respond to an Event, if a response is required.
     */
    Message?: string;
    /**
     * The moment the event occurred, which may be different to the moment it
     * was recorded.
     */
    Timestamp?: string;
    /**
     * The topic of the event. See the documentation on EventTopic.
     */
    Topic?: string;
};

export type models_Execution = {
    /**
     * AllocatedResources is the total resources allocated for the execution tasks.
     */
    AllocatedResources?: (models_AllocatedResources);
    /**
     * ComputeState observed state of the execution on the compute node
     */
    ComputeState?: (models_State_models_ExecutionStateType);
    /**
     * CreateTime is the time the execution has finished scheduling and been
     * verified by the plan applier.
     */
    CreateTime?: number;
    /**
     * DesiredState of the execution on the compute node
     */
    DesiredState?: (models_State_models_ExecutionDesiredStateType);
    /**
     * ID of the evaluation that generated this execution
     */
    EvalID?: string;
    /**
     * FollowupEvalID captures a follow up evaluation created to handle a failed execution
     * that can be rescheduled in the future
     */
    FollowupEvalID?: string;
    /**
     * ID of the execution (UUID)
     */
    ID?: string;
    /**
     * TODO: evaluate using a copy of the job instead of a pointer
     */
    Job?: (models_Job);
    /**
     * Job is the parent job of the task being allocated.
     * This is copied at execution time to avoid issues if the job
     * definition is updated.
     */
    JobID?: string;
    /**
     * ModifyTime is the time the execution was last updated.
     */
    ModifyTime?: number;
    /**
     * Name is a logical name of the execution.
     */
    Name?: string;
    /**
     * Namespace is the namespace the execution is created in
     */
    Namespace?: string;
    /**
     * NextExecution is the execution that this execution is being replaced by
     */
    NextExecution?: string;
    /**
     * NodeID is the node this is being placed on
     */
    NodeID?: string;
    /**
     * PreviousExecution is the execution that this execution is replacing
     */
    PreviousExecution?: string;
    /**
     * the published results for this execution
     */
    PublishedResult?: (models_SpecConfig);
    /**
     * Revision is increment each time the execution is updated.
     */
    Revision?: number;
    /**
     * RunOutput is the output of the run command
     * TODO: evaluate removing this from execution spec in favour of calling `bacalhau job logs`
     */
    RunOutput?: (models_RunCommandResult);
};

export type models_ExecutionDesiredStateType = 0 | 1 | 2;

export type models_ExecutionLog = {
    line?: string;
    type?: models_ExecutionLogType;
};

export type models_ExecutionLogType = 0 | 1 | 2;

export type models_ExecutionStateType = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;

export type models_FailureInjectionRequesterConfig = {
    isBadActor?: boolean;
};

export type models_GPU = {
    /**
     * Self-reported index of the device in the system
     */
    index?: number;
    /**
     * Total GPU memory in mebibytes (MiB)
     */
    memory?: number;
    /**
     * Model name of the GPU e.g. Tesla T4
     */
    name?: string;
    /**
     * PCI address of the device, in the format AAAA:BB:CC.C
     * Used to discover the correct device rendering cards
     */
    pciaddress?: string;
    /**
     * Maker of the GPU, e.g. NVidia, AMD, Intel
     */
    vendor?: (models_GPUVendor);
};

export type models_GPUVendor = 'NVIDIA' | 'AMD/ATI' | 'Intel';

export type models_InputSource = {
    /**
     * Alias is an optional reference to this input source that can be used for
     * dynamic linking to this input. (e.g. dynamic import in wasm by alias)
     */
    Alias?: string;
    /**
     * Source is the source of the artifact to be downloaded, e.g a URL, S3 bucket, etc.
     */
    Source?: (models_SpecConfig);
    /**
     * Target is the path where the artifact should be mounted on
     */
    Target?: string;
};

export type models_Job = {
    /**
     * Constraints is a selector which must be true for the compute node to run this job.
     */
    Constraints?: Array<models_LabelSelectorRequirement>;
    /**
     * Count is the number of replicas that should be scheduled.
     */
    Count?: number;
    CreateTime?: number;
    /**
     * ID is a unique identifier assigned to this job.
     * It helps to distinguish jobs with the same name after they have been deleted and re-created.
     * The ID is generated by the server and should not be set directly by the client.
     */
    ID?: string;
    /**
     * Labels is used to associate arbitrary labels with this job, which can be used
     * for filtering.
     * key=value
     */
    Labels?: {
        [key: string]: (string);
    };
    /**
     * Meta is used to associate arbitrary metadata with this job.
     */
    Meta?: {
        [key: string]: (string);
    };
    ModifyTime?: number;
    /**
     * Name is the logical name of the job used to refer to it.
     * Submitting a job with the same name as an existing job will result in an
     * update to the existing job.
     */
    Name?: string;
    /**
     * Namespace is the namespace this job is running in.
     */
    Namespace?: string;
    /**
     * Priority defines the scheduling priority of this job.
     */
    Priority?: number;
    /**
     * Revision is a per-job monotonically increasing revision number that is incremented
     * on each update to the job's state or specification
     */
    Revision?: number;
    /**
     * State is the current state of the job.
     */
    State?: (models_State_models_JobStateType);
    Tasks?: Array<models_Task>;
    /**
     * Type is the type of job this is, e.g. "daemon" or "batch".
     */
    Type?: string;
    /**
     * Version is a per-job monotonically increasing version number that is incremented
     * on each job specification update.
     */
    Version?: number;
};

export type models_JobHistory = {
    Event?: models_Event;
    ExecutionID?: string;
    /**
     * Deprecated: Left for backward compatibility with v1.4.x clients
     */
    ExecutionState?: (models_StateChange_models_ExecutionStateType);
    JobID?: string;
    /**
     * TODO: remove with v1.5
     * Deprecated: Left for backward compatibility with v1.4.x clients
     */
    JobState?: (models_StateChange_models_JobStateType);
    Time?: string;
    Type?: models_JobHistoryType;
};

export type models_JobHistoryType = 0 | 1 | 2;

export type models_JobSelectionDataLocality = 0 | 1;

export type models_JobSelectionPolicy = {
    /**
     * should we accept jobs that specify networking
     * the default is "reject"
     */
    accept_networked_jobs?: boolean;
    /**
     * this describes if we should run a job based on
     * where the data is located - i.e. if the data is "local"
     * or if the data is "anywhere"
     */
    locality?: (models_JobSelectionDataLocality);
    probe_exec?: string;
    /**
     * external hooks that decide if we should take on the job or not
     * if either of these are given they will override the data locality settings
     */
    probe_http?: string;
    /**
     * should we reject jobs that don't specify any data
     * the default is "accept"
     */
    reject_stateless_jobs?: boolean;
};

export type models_JobStateType = 0 | 1 | 2 | 3 | 4 | 5 | 6;

export type models_LabelSelectorRequirement = {
    /**
     * key is the label key that the selector applies to.
     */
    Key?: string;
    /**
     * operator represents a key's relationship to a set of values.
     * Valid operators are In, NotIn, Exists and KeyNotInImap.
     */
    Operator?: (selection_Operator);
    /**
     * values is an array of string values. If the operator is In or NotIn,
     * the values array must be non-empty. If the operator is Exists or KeyNotInImap,
     * the values array must be empty. This array is replaced during a strategic
     */
    Values?: Array<(string)>;
};

export type models_Network = 0 | 1 | 2;

export type models_NetworkConfig = {
    Domains?: Array<(string)>;
    Type?: models_Network;
};

export type models_NodeConnectionState = {
    connection?: 0 | 1;
};

export type models_NodeInfo = {
    BacalhauVersion?: models_BuildVersionInfo;
    ComputeNodeInfo?: models_ComputeNodeInfo;
    Labels?: {
        [key: string]: (string);
    };
    /**
     * TODO replace all access on this field with the `ID()` method
     */
    NodeID?: string;
    NodeType?: models_NodeType;
};

export type models_NodeMembershipState = {
    membership?: 0 | 1 | 2 | 3;
};

export type models_NodeState = {
    Connection?: models_NodeConnectionState;
    Info?: models_NodeInfo;
    Membership?: models_NodeMembershipState;
};

export type models_NodeType = 0 | 1 | 2;

export type models_Resources = {
    /**
     * CPU units
     */
    CPU?: number;
    /**
     * Disk in bytes
     */
    Disk?: number;
    /**
     * GPU units
     */
    GPU?: number;
    /**
     * GPU details
     */
    GPUs?: Array<models_GPU>;
    /**
     * Memory in bytes
     */
    Memory?: number;
};

export type models_ResourcesConfig = {
    /**
     * CPU https://github.com/BTBurke/k8sresource string
     */
    CPU?: string;
    /**
     * Memory github.com/dustin/go-humanize string
     */
    Disk?: string;
    GPU?: string;
    /**
     * Memory github.com/dustin/go-humanize string
     */
    Memory?: string;
};

export type models_ResultPath = {
    /**
     * Name
     */
    Name?: string;
    /**
     * The path to the file/dir
     */
    Path?: string;
};

export type models_RunCommandResult = {
    /**
     * Runner error
     */
    ErrorMsg?: string;
    /**
     * exit code of the run.
     */
    ExitCode?: number;
    /**
     * bool describing if stderr was truncated
     */
    StderrTruncated?: boolean;
    /**
     * stdout of the run. Yaml provided for `describe` output
     */
    Stdout?: string;
    /**
     * bool describing if stdout was truncated
     */
    StdoutTruncated?: boolean;
    /**
     * stderr of the run.
     */
    stderr?: string;
};

export type models_SpecConfig = {
    /**
     * Params is a map of the config params
     */
    Params?: unknown;
    /**
     * Type of the config
     */
    Type?: string;
};

export type models_State_models_ExecutionDesiredStateType = {
    /**
     * Message is a human readable message describing the state.
     */
    Message?: string;
    /**
     * StateType is the current state of the object.
     */
    StateType?: (models_ExecutionDesiredStateType);
};

export type models_State_models_ExecutionStateType = {
    /**
     * Message is a human readable message describing the state.
     */
    Message?: string;
    /**
     * StateType is the current state of the object.
     */
    StateType?: (models_ExecutionStateType);
};

export type models_State_models_JobStateType = {
    /**
     * Message is a human readable message describing the state.
     */
    Message?: string;
    /**
     * StateType is the current state of the object.
     */
    StateType?: (models_JobStateType);
};

export type models_StateChange_models_ExecutionStateType = {
    New?: models_ExecutionStateType;
    Previous?: models_ExecutionStateType;
};

export type models_StateChange_models_JobStateType = {
    New?: models_JobStateType;
    Previous?: models_JobStateType;
};

export type models_Task = {
    Engine?: models_SpecConfig;
    /**
     * Map of environment variables to be used by the driver
     */
    Env?: {
        [key: string]: (string);
    };
    /**
     * InputSources is a list of remote artifacts to be downloaded before running the task
     * and mounted into the task.
     */
    InputSources?: Array<models_InputSource>;
    /**
     * Meta is used to associate arbitrary metadata with this task.
     */
    Meta?: {
        [key: string]: (string);
    };
    /**
     * Name of the task
     */
    Name?: string;
    Network?: models_NetworkConfig;
    Publisher?: models_SpecConfig;
    /**
     * ResourcesConfig is the resources needed by this task
     */
    Resources?: (models_ResourcesConfig);
    /**
     * ResultPaths is a list of task volumes to be included in the task's published result
     */
    ResultPaths?: Array<models_ResultPath>;
    Timeouts?: models_TimeoutConfig;
};

export type models_TimeoutConfig = {
    /**
     * ExecutionTimeout is the maximum amount of time a task is allowed to run in seconds.
     * Zero means no timeout, such as for a daemon task.
     */
    ExecutionTimeout?: number;
    /**
     * QueueTimeout is the maximum amount of time a task is allowed to wait in the orchestrator
     * queue in seconds before being scheduled. Zero means no timeout.
     */
    QueueTimeout?: number;
    /**
     * TotalTimeout is the maximum amount of time a task is allowed to complete in seconds.
     * This includes the time spent in the queue, the time spent executing and the time spent retrying.
     * Zero means no timeout.
     */
    TotalTimeout?: number;
};

export type selection_Operator = '!' | '=' | '==' | 'in' | '!=' | 'notin' | 'exists' | 'gt' | 'lt';

export type shared_VersionRequest = {
    client_id?: string;
};

export type shared_VersionResponse = {
    build_version_info?: models_BuildVersionInfo;
};

export type types_APIConfig = {
    /**
     * ClientTLS specifies tls options for the client connecting to the
     * API.
     */
    clientTLS?: (types_ClientTLSConfig);
    /**
     * Host is the hostname of an environment's public API servers.
     */
    host?: string;
    /**
     * Port is the port that an environment serves the public API on.
     */
    port?: number;
    /**
     * TLS returns information about how TLS is configured for the public server.
     * This is only used in APIConfig for NodeConfig.ServerAPI
     */
    tls?: (types_TLSConfiguration);
};

export type types_AuthConfig = {
    /**
     * AccessPolicyPath is the path to a file or directory that will be loaded as
     * the policy to apply to all inbound API requests. If unspecified, a policy
     * that permits access to all API endpoints to both authenticated and
     * unauthenticated users (the default as of v1.2.0) will be used.
     */
    accessPolicyPath?: string;
    /**
     * Methods maps "method names" to authenticator implementations. A method
     * name is a human-readable string chosen by the person configuring the
     * system that is shown to users to help them pick the authentication method
     * they want to use. There can be multiple usages of the same Authenticator
     * *type* but with different configs and parameters, each identified with a
     * unique method name.
     *
     * For example, if an implementation wants to allow users to log in with
     * Github or Bitbucket, they might both use an authenticator implementation
     * of type "oidc", and each would appear once on this provider with key /
     * method name "github" and "bitbucket".
     *
     * By default, only a single authentication method that accepts
     * authentication via client keys will be enabled.
     */
    methods?: {
        [key: string]: types_AuthenticatorConfig;
    };
    /**
     * TokensPath is the location where a state file of tokens will be stored.
     * By default it will be local to the Bacalhau repo, but can be any location
     * in the host filesystem. Tokens are sensitive and should be stored in a
     * location that is only readable to the current user.
     * Deprecated: replaced by cfg.AuthTokensPath()
     */
    tokensPath?: string;
};

export type types_AuthenticatorConfig = {
    policyPath?: string;
    type?: authn_MethodType;
};

export type types_BacalhauConfig = {
    auth?: types_AuthConfig;
    /**
     * NB(forrest): this field shouldn't be persisted yet.
     */
    dataDir?: string;
    metrics?: types_MetricsConfig;
    node?: types_NodeConfig;
    update?: types_UpdateConfig;
    user?: types_UserConfig;
};

export type types_CapacityConfig = {
    defaultJobResourceLimits?: models_ResourcesConfig;
    ignorePhysicalResourceLimits?: boolean;
    /**
     * Per job amount of resource the system can be using at one time.
     */
    jobResourceLimits?: (models_ResourcesConfig);
    /**
     * Total amount of resource the system can be using at one time in aggregate for all jobs.
     */
    totalResourceLimits?: (models_ResourcesConfig);
};

export type types_ClientTLSConfig = {
    /**
     * Used for NodeConfig.ClientAPI, specifies the location of a ca certificate
     * file (primarily for self-signed server certs). Will use HTTPS for requests.
     */
    cacert?: string;
    /**
     * Used for NodeConfig.ClientAPI, and when true instructs the client to use
     * HTTPS, but not to attempt to verify the certificate.
     */
    insecure?: boolean;
    /**
     * Used for NodeConfig.ClientAPI, instructs the client to connect over
     * TLS.  Auto enabled if Insecure or CACert are specified.
     */
    useTLS?: boolean;
};

export type types_ComputeConfig = {
    capacity?: types_CapacityConfig;
    controlPlaneSettings?: types_ComputeControlPlaneConfig;
    executionStore?: types_JobStoreConfig;
    jobSelection?: models_JobSelectionPolicy;
    jobTimeouts?: types_JobTimeoutConfig;
    localPublisher?: types_LocalPublisherConfig;
    logStreamConfig?: types_LogStreamConfig;
    logging?: types_LoggingConfig;
    manifestCache?: types_DockerCacheConfig;
};

export type types_ComputeControlPlaneConfig = {
    /**
     * How often the compute node will send a heartbeat to the requester node to let it know
     * that the compute node is still alive. This should be less than the requester's configured
     * heartbeat timeout to avoid flapping.
     */
    heartbeatFrequency?: (types_Duration);
    /**
     * This is the pubsub topic that the compute node will use to send heartbeats to the requester node.
     */
    heartbeatTopic?: string;
    /**
     * The frequency with which the compute node will send node info (inc current labels)
     * to the controlling requester node.
     */
    infoUpdateFrequency?: (types_Duration);
    /**
     * How often the compute node will send current resource availability to the requester node.
     */
    resourceUpdateFrequency?: (types_Duration);
};

export type types_DockerCacheConfig = {
    duration?: types_Duration;
    frequency?: types_Duration;
    size?: number;
};

export type types_Duration = -9223372036854776000 | 9223372036854776000 | 1 | 1000 | 1000000 | 1000000000 | 60000000000 | 3600000000000;

export type types_EvaluationBrokerConfig = {
    evalBrokerInitialRetryDelay?: types_Duration;
    evalBrokerMaxRetryCount?: number;
    evalBrokerSubsequentRetryDelay?: types_Duration;
    evalBrokerVisibilityTimeout?: types_Duration;
};

export type types_FeatureConfig = {
    engines?: Array<(string)>;
    publishers?: Array<(string)>;
    storages?: Array<(string)>;
};

export type types_FreeSpace = {
    root?: types_MountStatus;
    tmp?: types_MountStatus;
};

export type types_HealthInfo = {
    FreeSpace?: types_FreeSpace;
};

export type types_IpfsConfig = {
    /**
     * Connect is the multiaddress to connect to for IPFS.
     */
    connect?: string;
};

export type types_JobDefaults = {
    executionTimeout?: types_Duration;
    queueTimeout?: types_Duration;
    totalTimeout?: types_Duration;
};

export type types_JobStoreConfig = {
    path?: string;
    type?: types_StorageType;
};

export type types_JobTimeoutConfig = {
    /**
     * DefaultJobExecutionTimeout default value for the execution timeout this compute node will assign to jobs with
     * no timeout requirement defined.
     */
    defaultJobExecutionTimeout?: (types_Duration);
    /**
     * JobExecutionTimeoutClientIDBypassList is the list of clients that are allowed to bypass the job execution timeout
     * check.
     */
    jobExecutionTimeoutClientIDBypassList?: Array<(string)>;
    /**
     * JobNegotiationTimeout default timeout value to hold a bid for a job
     */
    jobNegotiationTimeout?: (types_Duration);
    /**
     * MaxJobExecutionTimeout default value for the maximum execution timeout this compute node supports. Jobs with
     * higher timeout requirements will not be bid on.
     */
    maxJobExecutionTimeout?: (types_Duration);
    /**
     * MinJobExecutionTimeout default value for the minimum execution timeout this compute node supports. Jobs with
     * lower timeout requirements will not be bid on.
     */
    minJobExecutionTimeout?: (types_Duration);
};

export type types_LocalPublisherConfig = {
    address?: string;
    directory?: string;
    port?: number;
};

export type types_LogStreamConfig = {
    /**
     * How many messages to buffer in the log stream channel, per stream
     */
    channelBufferSize?: number;
};

export type types_LoggingConfig = {
    /**
     * logging running executions
     */
    logRunningExecutionsInterval?: (types_Duration);
};

export type types_MetricsConfig = {
    eventTracerPath?: string;
};

export type types_MountStatus = {
    All?: number;
    Free?: number;
    Used?: number;
};

export type types_NetworkClusterConfig = {
    advertisedAddress?: string;
    name?: string;
    peers?: Array<(string)>;
    port?: number;
};

export type types_NetworkConfig = {
    advertisedAddress?: string;
    authSecret?: string;
    cluster?: types_NetworkClusterConfig;
    orchestrators?: Array<(string)>;
    port?: number;
    storeDir?: string;
};

export type types_NodeConfig = {
    /**
     * AllowListedLocalPaths contains local paths that are allowed to be mounted into jobs
     */
    allowListedLocalPaths?: Array<(string)>;
    clientAPI?: types_APIConfig;
    compute?: types_ComputeConfig;
    /**
     * TODO(forrest) [refactor]: rename this to ExecutorStoragePath
     * Deprecated: replaced by cfg.ComputeDir()
     */
    computeStoragePath?: string;
    /**
     * What features should not be enabled even if installed
     */
    disabledFeatures?: (types_FeatureConfig);
    downloadURLRequestRetries?: number;
    downloadURLRequestTimeout?: types_Duration;
    /**
     * Deprecated: replaced by cfg.PluginsDir()
     */
    executorPluginPath?: string;
    ipfs?: types_IpfsConfig;
    /**
     * Labels to apply to the node that can be used for node selection and filtering
     */
    labels?: {
        [key: string]: (string);
    };
    loggingMode?: logger_LogMode;
    name?: string;
    nameProvider?: string;
    network?: types_NetworkConfig;
    requester?: types_RequesterConfig;
    serverAPI?: types_APIConfig;
    strictVersionMatch?: boolean;
    /**
     * Type is "compute", "requester" or both
     */
    type?: Array<(string)>;
    volumeSizeRequestTimeout?: types_Duration;
    /**
     * Configuration for the web UI
     */
    webUI?: (types_WebUIConfig);
};

export type types_RequesterConfig = {
    controlPlaneSettings?: types_RequesterControlPlaneConfig;
    defaultPublisher?: string;
    evaluationBroker?: types_EvaluationBrokerConfig;
    /**
     * URL where to send external verification requests to.
     */
    externalVerifierHook?: string;
    failureInjectionConfig?: models_FailureInjectionRequesterConfig;
    housekeepingBackgroundTaskInterval?: types_Duration;
    jobDefaults?: types_JobDefaults;
    /**
     * How the node decides what jobs to run.
     */
    jobSelectionPolicy?: (models_JobSelectionPolicy);
    jobStore?: types_JobStoreConfig;
    /**
     * ManualNodeApproval is a flag that determines if nodes should be manually approved or not.
     * By default, nodes are auto-approved to simplify upgrades, by setting this property to
     * true, nodes will need to be manually approved before they are included in node selection.
     */
    manualNodeApproval?: boolean;
    nodeInfoStoreTTL?: types_Duration;
    nodeRankRandomnessRange?: number;
    overAskForBidsFactor?: number;
    scheduler?: types_SchedulerConfig;
    storageProvider?: types_StorageProviderConfig;
    tagCache?: types_DockerCacheConfig;
    translationEnabled?: boolean;
    worker?: types_WorkerConfig;
};

export type types_RequesterControlPlaneConfig = {
    /**
     * This setting is the time period after which a compute node is considered to be unresponsive.
     * If the compute node misses two of these frequencies, it will be marked as unknown.  The compute
     * node should have a frequency setting less than this one to ensure that it does not keep
     * switching between unknown and active too frequently.
     */
    heartbeatCheckFrequency?: (types_Duration);
    /**
     * This is the pubsub topic that the compute node will use to send heartbeats to the requester node.
     */
    heartbeatTopic?: string;
    /**
     * This is the time period after which a compute node is considered to be disconnected. If the compute
     * node does not deliver a heartbeat every `NodeDisconnectedAfter` then it is considered disconnected.
     */
    nodeDisconnectedAfter?: (types_Duration);
};

export type types_S3StorageProviderConfig = {
    preSignedURLDisabled?: boolean;
    preSignedURLExpiration?: types_Duration;
};

export type types_SchedulerConfig = {
    nodeOverSubscriptionFactor?: number;
    queueBackoff?: types_Duration;
};

export type types_StorageProviderConfig = {
    s3?: types_S3StorageProviderConfig;
};

export type types_StorageType = 0 | 1;

export type types_TLSConfiguration = {
    /**
     * AutoCert specifies a hostname for a certificate to be obtained via ACME.
     * This is only used by the server, and only by the requester node when it
     * has a publicly resolvable domain name.
     */
    autoCert?: string;
    /**
     * AutoCertCachePath specifies the directory where the autocert process
     * will cache certificates to avoid rate limits.
     */
    autoCertCachePath?: string;
    /**
     * SelfSignedCert will auto-generate a self-signed certificate for the
     * requester node if TLS certificates have not been provided.
     */
    selfSigned?: boolean;
    /**
     * ServerCertificate specifies the location of a TLS certificate to be used
     * by the requester to serve TLS requests
     */
    serverCertificate?: string;
    /**
     * ServerKey is the TLS server key to match the certificate to allow the
     * requester to server TLS.
     */
    serverKey?: string;
};

export type types_UpdateConfig = {
    checkFrequency?: types_Duration;
    skipChecks?: boolean;
};

export type types_UserConfig = {
    installationID?: string;
    /**
     * KeyPath is deprecated
     * Deprecated: replaced by cfg.UserKeyPath()
     */
    keyPath?: string;
};

export type types_WebUIConfig = {
    enabled?: boolean;
    port?: number;
};

export type types_WorkerConfig = {
    workerCount?: number;
    workerEvalDequeueBaseBackoff?: types_Duration;
    workerEvalDequeueMaxBackoff?: types_Duration;
    workerEvalDequeueTimeout?: types_Duration;
};

export type HomeResponse = (string);

export type AgentAliveResponse = (string);

export type AgentConfigResponse = (types_BacalhauConfig);

export type AgentDebugResponse = (models_DebugInfo);

export type AgentNodeResponse = (models_NodeInfo);

export type AgentVersionResponse = (apimodels_GetVersionResponse);

export type ApiServerDebugResponse = (string);

export type HealthzResponse = (types_HealthInfo);

export type IdResponse = (string);

export type LivezResponse = (string);

export type NodeInfoResponse = (models_NodeInfo);

export type OrchestratorListJobsData = {
    /**
     * Limit the number of jobs returned
     */
    limit?: number;
    /**
     * Namespace to get the jobs for
     */
    namespace?: string;
    /**
     * Token to get the next page of jobs
     */
    nextToken?: string;
    /**
     * Order the jobs by the given field
     */
    orderBy?: string;
    /**
     * Reverse the order of the jobs
     */
    reverse?: boolean;
};

export type OrchestratorListJobsResponse = (apimodels_ListJobsResponse);

export type OrchestratorPutJobData = {
    /**
     * Job to submit
     */
    putJobRequest: apimodels_PutJobRequest;
};

export type OrchestratorPutJobResponse = (apimodels_PutJobResponse);

export type OrchestratorGetJobData = {
    /**
     * ID to get the job for
     */
    id: string;
    /**
     * Takes history and executions as options. If empty will not include anything else.
     */
    include?: string;
    /**
     * Number of history or executions to fetch. Should be used in conjugation with include
     */
    limit?: number;
};

export type OrchestratorGetJobResponse = (apimodels_GetJobResponse);

export type OrchestratorStopJobData = {
    /**
     * ID to stop the job for
     */
    id: string;
    /**
     * Reason for stopping the job
     */
    reason?: string;
};

export type OrchestratorStopJobResponse = (apimodels_StopJobResponse);

export type OrchestratorJobExecutionsData = {
    /**
     * ID to get the job executions for
     */
    id: string;
    /**
     * Limit the number of executions returned
     */
    limit?: number;
    /**
     * Namespace to get the jobs for
     */
    namespace?: string;
    /**
     * Token to get the next page of executions
     */
    nextToken?: string;
    /**
     * Order the executions by the given field
     */
    orderBy: string;
    /**
     * Reverse the order of the executions
     */
    reverse?: boolean;
};

export type OrchestratorJobExecutionsResponse = (apimodels_ListJobExecutionsResponse);

export type OrchestratorJobHistoryData = {
    /**
     * Only return history of this event type
     */
    eventType?: string;
    /**
     * Only return history of this execution ID
     */
    executionId?: string;
    /**
     * ID to get the job history for
     */
    id: string;
    /**
     * Token to get the next page of the jobs
     */
    nextToken?: string;
    /**
     * Only return history since this time
     */
    since?: string;
};

export type OrchestratorJobHistoryResponse = (apimodels_ListJobHistoryResponse);

export type OrchestratorLogsData = {
    /**
     * Fetch logs for a specific execution
     */
    executionId?: string;
    /**
     * Follow the logs
     */
    follow?: boolean;
    /**
     * ID of the job to stream logs for
     */
    id: string;
    /**
     * Fetch historical logs
     */
    tail?: boolean;
};

export type OrchestratorJobResultsData = {
    /**
     * ID to get the job results for
     */
    id: string;
};

export type OrchestratorJobResultsResponse = (apimodels_ListJobResultsResponse);

export type OrchestratorListNodesData = {
    /**
     * Filter Approval
     */
    filterApproval?: string;
    /**
     * Filter Status
     */
    filterStatus?: string;
    /**
     * Limit the number of node returned
     */
    limit?: number;
    /**
     * Token to get the next page of nodes
     */
    nextToken?: string;
    /**
     * Order the nodes by given field
     */
    orderBy?: string;
    /**
     * Reverse the order of the nodes
     */
    reverse?: boolean;
};

export type OrchestratorListNodesResponse = (apimodels_ListNodesResponse);

export type OrchestratorUpdateNodeData = {
    /**
     * ID of the orchestrator node.
     */
    id: string;
    /**
     * Put Node Request
     */
    putNodeRequest: apimodels_PutNodeRequest;
};

export type OrchestratorUpdateNodeResponse = (apimodels_PutNodeResponse);

export type OrchestratorGetNodeData = {
    /**
     * ID of the orchestrator node to fetch for.
     */
    id: string;
};

export type OrchestratorGetNodeResponse = (apimodels_GetNodeResponse);

export type ApiServerVersionData = {
    /**
     * Request must specify a `client_id`. To retrieve your `client_id`, you can do the following: (1) submit a dummy job to Bacalhau (or use one you created before), (2) run `bacalhau describe <job-id>` and fetch the `ClientID` field.
     */
    versionRequest: shared_VersionRequest;
};

export type ApiServerVersionResponse = (shared_VersionResponse);