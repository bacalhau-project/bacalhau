// This file is auto-generated by @hey-api/openapi-ts

export type apimodels_GetAgentLicenseResponse = {
    /**
     * the `aud` (Audience) claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.3
     */
    aud?: Array<(string)>;
    capabilities?: {
        [key: string]: (string);
    };
    customer_id?: string;
    /**
     * the `exp` (Expiration Time) claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.4
     */
    exp?: (jwt_NumericDate);
    /**
     * the `iat` (Issued At) claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.6
     */
    iat?: (jwt_NumericDate);
    /**
     * the `iss` (Issuer) claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.1
     */
    iss?: string;
    /**
     * the `jti` (JWT ID) claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.7
     */
    jti?: string;
    license_id?: string;
    license_type?: string;
    license_version?: string;
    metadata?: {
        [key: string]: (string);
    };
    /**
     * the `nbf` (Not Before) claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.5
     */
    nbf?: (jwt_NumericDate);
    /**
     * Add your custom license claims here
     */
    product?: string;
    /**
     * the `sub` (Subject) claim. See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.2
     */
    sub?: string;
};

export type apimodels_GetJobResponse = {
    Executions?: apimodels_ListJobExecutionsResponse;
    History?: apimodels_ListJobHistoryResponse;
    Job?: models_Job;
};

export type apimodels_GetNodeResponse = {
    Node?: models_NodeState;
};

export type apimodels_GetVersionResponse = {
    BuildDate?: string;
    GOARCH?: string;
    GOOS?: string;
    GitCommit?: string;
    GitVersion?: string;
    Major?: string;
    Minor?: string;
};

export type apimodels_HTTPCredential = {
    /**
     * For authorization schemes that provide multiple values, a map of names to
     * values providing the credential
     */
    params?: {
        [key: string]: (string);
    };
    /**
     * An HTTP authorization scheme, such as one registered with IANA
     * https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml
     */
    scheme?: string;
    /**
     * For authorization schemes that only provide a single value, such as
     * Basic, the single string value providing the credential
     */
    value?: string;
};

export type apimodels_IsAliveResponse = {
    Status?: string;
};

export type apimodels_ListJobExecutionsResponse = {
    Items?: Array<models_Execution>;
    NextToken?: string;
};

export type apimodels_ListJobHistoryResponse = {
    Items?: Array<models_JobHistory>;
    NextToken?: string;
};

export type apimodels_ListJobResultsResponse = {
    Items?: Array<models_SpecConfig>;
    NextToken?: string;
};

export type apimodels_ListJobsResponse = {
    Items?: Array<models_Job>;
    NextToken?: string;
};

export type apimodels_ListNodesResponse = {
    NextToken?: string;
    Nodes?: Array<models_NodeState>;
};

export type apimodels_PutJobRequest = {
    Job?: models_Job;
    credential?: apimodels_HTTPCredential;
    idempotencyToken?: string;
    namespace?: string;
};

export type apimodels_PutJobResponse = {
    EvaluationID?: string;
    JobID?: string;
    Warnings?: Array<(string)>;
};

export type apimodels_PutNodeRequest = {
    Action?: string;
    Message?: string;
    NodeID?: string;
    credential?: apimodels_HTTPCredential;
    idempotencyToken?: string;
    namespace?: string;
};

export type apimodels_PutNodeResponse = {
    Error?: string;
    Success?: boolean;
};

export type apimodels_StopJobResponse = {
    EvaluationID?: string;
};

export type jwt_NumericDate = {
    'time.Time'?: string;
};

export type models_AllocatedResources = {
    Tasks?: {
        [key: string]: models_Resources;
    };
};

export type models_BuildVersionInfo = {
    BuildDate?: string;
    GOARCH?: string;
    GOOS?: string;
    GitCommit?: string;
    GitVersion?: string;
    Major?: string;
    Minor?: string;
};

export type models_ComputeNodeInfo = {
    AvailableCapacity?: models_Resources;
    EnqueuedExecutions?: number;
    ExecutionEngines?: Array<(string)>;
    MaxCapacity?: models_Resources;
    MaxJobRequirements?: models_Resources;
    Publishers?: Array<(string)>;
    QueueCapacity?: models_Resources;
    RunningExecutions?: number;
    StorageSources?: Array<(string)>;
};

export type models_ConnectionState = {
    /**
     * Connection tracking
     */
    ConnectedSince?: string;
    DisconnectedSince?: string;
    /**
     * Message sequencing for reliable delivery
     */
    LastComputeSeqNum?: number;
    LastError?: string;
    /**
     * Last successful heartbeat timestamp
     */
    LastHeartbeat?: string;
    /**
     * Last seq received from orchestrator
     */
    LastOrchestratorSeqNum?: number;
    /**
     * Connection status
     */
    Status?: (models_NodeConnectionState);
};

export type models_DebugInfo = {
    component?: string;
    info?: unknown;
};

export type models_Event = {
    /**
     * Any additional metadata that the system or user may need to know about
     * the event in order to handle it properly.
     */
    Details?: {
        [key: string]: (string);
    };
    /**
     * A human-readable string giving the user all the information they need to
     * understand and respond to an Event, if a response is required.
     */
    Message?: string;
    /**
     * The moment the event occurred, which may be different to the moment it
     * was recorded.
     */
    Timestamp?: string;
    /**
     * The topic of the event. See the documentation on EventTopic.
     */
    Topic?: string;
};

export type models_Execution = {
    /**
     * AllocatedResources is the total resources allocated for the execution tasks.
     */
    AllocatedResources?: (models_AllocatedResources);
    /**
     * ComputeState observed state of the execution on the compute node
     */
    ComputeState?: (models_State_models_ExecutionStateType);
    /**
     * CreateTime is the time the execution has finished scheduling and been
     * verified by the plan applier.
     */
    CreateTime?: number;
    /**
     * DesiredState of the execution on the compute node
     */
    DesiredState?: (models_State_models_ExecutionDesiredStateType);
    /**
     * ID of the evaluation that generated this execution
     */
    EvalID?: string;
    /**
     * FollowupEvalID captures a follow up evaluation created to handle a failed execution
     * that can be rescheduled in the future
     */
    FollowupEvalID?: string;
    /**
     * ID of the execution (UUID)
     */
    ID?: string;
    /**
     * TODO: evaluate using a copy of the job instead of a pointer
     */
    Job?: (models_Job);
    /**
     * Job is the parent job of the task being allocated.
     * This is copied at execution time to avoid issues if the job
     * definition is updated.
     */
    JobID?: string;
    /**
     * ModifyTime is the time the execution was last updated.
     */
    ModifyTime?: number;
    /**
     * Name is a logical name of the execution.
     */
    Name?: string;
    /**
     * Namespace is the namespace the execution is created in
     */
    Namespace?: string;
    /**
     * NextExecution is the execution that this execution is being replaced by
     */
    NextExecution?: string;
    /**
     * NodeID is the node this is being placed on
     */
    NodeID?: string;
    /**
     * PartitionIndex is the index of this execution in the job's total partitions (0-based)
     * Only relevant when Job.Count > 1
     */
    PartitionIndex?: number;
    /**
     * PreviousExecution is the execution that this execution is replacing
     */
    PreviousExecution?: string;
    /**
     * the published results for this execution
     */
    PublishedResult?: (models_SpecConfig);
    /**
     * Revision is increment each time the execution is updated.
     */
    Revision?: number;
    /**
     * RunOutput is the output of the run command
     * TODO: evaluate removing this from execution spec in favour of calling `bacalhau job logs`
     */
    RunOutput?: (models_RunCommandResult);
};

export enum models_ExecutionDesiredStateType {
    ExecutionDesiredStatePending = 0,
    ExecutionDesiredStateRunning = 1,
    ExecutionDesiredStateStopped = 2
}

export type models_ExecutionLog = {
    line?: string;
    type?: models_ExecutionLogType;
};

export enum models_ExecutionLogType {
    executionLogTypeUnknown = 0,
    ExecutionLogTypeSTDOUT = 1,
    ExecutionLogTypeSTDERR = 2
}

export enum models_ExecutionStateType {
    ExecutionStateUndefined = 0,
    ExecutionStateNew = 1,
    ExecutionStateAskForBid = 2,
    ExecutionStateAskForBidAccepted = 3,
    ExecutionStateAskForBidRejected = 4,
    ExecutionStateBidAccepted = 5,
    ExecutionStateRunning = 6,
    ExecutionStatePublishing = 7,
    ExecutionStateBidRejected = 8,
    ExecutionStateCompleted = 9,
    ExecutionStateFailed = 10,
    ExecutionStateCancelled = 11
}

export type models_GPU = {
    /**
     * Self-reported index of the device in the system
     */
    index?: number;
    /**
     * Total GPU memory in mebibytes (MiB)
     */
    memory?: number;
    /**
     * Model name of the GPU e.g. Tesla T4
     */
    name?: string;
    /**
     * PCI address of the device, in the format AAAA:BB:CC.C
     * Used to discover the correct device rendering cards
     */
    pciaddress?: string;
    /**
     * Maker of the GPU, e.g. NVidia, AMD, Intel
     */
    vendor?: (models_GPUVendor);
};

export enum models_GPUVendor {
    GPUVendorNvidia = 'NVIDIA',
    GPUVendorAMDATI = 'AMD/ATI',
    GPUVendorIntel = 'Intel'
}

export type models_InputSource = {
    /**
     * Alias is an optional reference to this input source that can be used for
     * dynamic linking to this input. (e.g. dynamic import in wasm by alias)
     */
    Alias?: string;
    /**
     * Source is the source of the artifact to be downloaded, e.g a URL, S3 bucket, etc.
     */
    Source?: (models_SpecConfig);
    /**
     * Target is the path where the artifact should be mounted on
     */
    Target?: string;
};

export type models_Job = {
    /**
     * Constraints is a selector which must be true for the compute node to run this job.
     */
    Constraints?: Array<models_LabelSelectorRequirement>;
    /**
     * Count is the number of replicas that should be scheduled.
     */
    Count?: number;
    CreateTime?: number;
    /**
     * ID is a unique identifier assigned to this job.
     * It helps to distinguish jobs with the same name after they have been deleted and re-created.
     * The ID is generated by the server and should not be set directly by the client.
     */
    ID?: string;
    /**
     * Labels is used to associate arbitrary labels with this job, which can be used
     * for filtering.
     * key=value
     */
    Labels?: {
        [key: string]: (string);
    };
    /**
     * Meta is used to associate arbitrary metadata with this job.
     */
    Meta?: {
        [key: string]: (string);
    };
    ModifyTime?: number;
    /**
     * Name is the logical name of the job used to refer to it.
     * Submitting a job with the same name as an existing job will result in an
     * update to the existing job.
     */
    Name?: string;
    /**
     * Namespace is the namespace this job is running in.
     */
    Namespace?: string;
    /**
     * Priority defines the scheduling priority of this job.
     */
    Priority?: number;
    /**
     * Revision is a per-job monotonically increasing revision number that is incremented
     * on each update to the job's state or specification
     */
    Revision?: number;
    /**
     * State is the current state of the job.
     */
    State?: (models_State_models_JobStateType);
    Tasks?: Array<models_Task>;
    /**
     * Type is the type of job this is, e.g. "daemon" or "batch".
     */
    Type?: string;
    /**
     * Version is a per-job monotonically increasing version number that is incremented
     * on each job specification update.
     */
    Version?: number;
};

export type models_JobHistory = {
    Event?: models_Event;
    ExecutionID?: string;
    /**
     * Deprecated: Left for backward compatibility with v1.4.x clients
     */
    ExecutionState?: (models_StateChange_models_ExecutionStateType);
    JobID?: string;
    /**
     * TODO: remove with v1.5
     * Deprecated: Left for backward compatibility with v1.4.x clients
     */
    JobState?: (models_StateChange_models_JobStateType);
    SeqNum?: number;
    Time?: string;
    Type?: models_JobHistoryType;
};

export enum models_JobHistoryType {
    JobHistoryTypeUndefined = 0,
    JobHistoryTypeJobLevel = 1,
    JobHistoryTypeExecutionLevel = 2
}

export enum models_JobSelectionDataLocality {
    Local = 0,
    Anywhere = 1
}

export enum models_JobStateType {
    JobStateTypeUndefined = 0,
    JobStateTypePending = 1,
    JobStateTypeQueued = 2,
    JobStateTypeRunning = 3,
    JobStateTypeCompleted = 4,
    JobStateTypeFailed = 5,
    JobStateTypeStopped = 6
}

export type models_LabelSelectorRequirement = {
    /**
     * key is the label key that the selector applies to.
     */
    Key?: string;
    /**
     * operator represents a key's relationship to a set of values.
     * Valid operators are In, NotIn, Exists and KeyNotInImap.
     */
    Operator?: (selection_Operator);
    /**
     * values is an array of string values. If the operator is In or NotIn,
     * the values array must be non-empty. If the operator is Exists or KeyNotInImap,
     * the values array must be empty. This array is replaced during a strategic
     */
    Values?: Array<(string)>;
};

export enum models_Network {
    NetworkNone = 0,
    NetworkFull = 1,
    NetworkHTTP = 2
}

export type models_NetworkConfig = {
    Domains?: Array<(string)>;
    Type?: models_Network;
};

export type models_NodeConnectionState = {
    connection?: 0 | 1;
};

export type models_NodeInfo = {
    BacalhauVersion?: models_BuildVersionInfo;
    ComputeNodeInfo?: models_ComputeNodeInfo;
    Labels?: {
        [key: string]: (string);
    };
    NodeID?: string;
    NodeType?: models_NodeType;
    /**
     * SupportedProtocols indicates which communication protocols this node supports
     */
    SupportedProtocols?: Array<models_Protocol>;
};

export type models_NodeMembershipState = {
    membership?: 0 | 1 | 2 | 3;
};

export type models_NodeState = {
    /**
     * Deprecated: Use ConnectionState.Status instead
     */
    Connection?: (models_NodeConnectionState);
    /**
     * Connection and messaging state
     */
    ConnectionState?: (models_ConnectionState);
    /**
     * Durable node information
     */
    Info?: (models_NodeInfo);
    Membership?: models_NodeMembershipState;
};

export enum models_NodeType {
    nodeTypeUndefined = 0,
    NodeTypeRequester = 1,
    NodeTypeCompute = 2
}

export enum models_Protocol {
    ProtocolNCLV1 = 'ncl/v1',
    ProtocolBProtocolV2 = 'bprotocol/v2'
}

export type models_Resources = {
    /**
     * CPU units
     */
    CPU?: number;
    /**
     * Disk in bytes
     */
    Disk?: number;
    /**
     * GPU units
     */
    GPU?: number;
    /**
     * GPU details
     */
    GPUs?: Array<models_GPU>;
    /**
     * Memory in bytes
     */
    Memory?: number;
};

export type models_ResourcesConfig = {
    /**
     * CPU https://github.com/BTBurke/k8sresource string
     */
    CPU?: string;
    /**
     * Memory github.com/dustin/go-humanize string
     */
    Disk?: string;
    GPU?: string;
    /**
     * Memory github.com/dustin/go-humanize string
     */
    Memory?: string;
};

export type models_ResultPath = {
    /**
     * Name
     */
    Name?: string;
    /**
     * The path to the file/dir
     */
    Path?: string;
};

export type models_RunCommandResult = {
    /**
     * Runner error
     */
    ErrorMsg?: string;
    /**
     * exit code of the run.
     */
    ExitCode?: number;
    /**
     * bool describing if stderr was truncated
     */
    StderrTruncated?: boolean;
    /**
     * stdout of the run. Yaml provided for `describe` output
     */
    Stdout?: string;
    /**
     * bool describing if stdout was truncated
     */
    StdoutTruncated?: boolean;
    /**
     * stderr of the run.
     */
    stderr?: string;
};

export type models_SpecConfig = {
    /**
     * Params is a map of the config params
     */
    Params?: unknown;
    /**
     * Type of the config
     */
    Type?: string;
};

export type models_State_models_ExecutionDesiredStateType = {
    /**
     * Details is a map of additional details about the state.
     */
    Details?: {
        [key: string]: (string);
    };
    /**
     * Message is a human readable message describing the state.
     */
    Message?: string;
    /**
     * StateType is the current state of the object.
     */
    StateType?: (models_ExecutionDesiredStateType);
};

export type models_State_models_ExecutionStateType = {
    /**
     * Details is a map of additional details about the state.
     */
    Details?: {
        [key: string]: (string);
    };
    /**
     * Message is a human readable message describing the state.
     */
    Message?: string;
    /**
     * StateType is the current state of the object.
     */
    StateType?: (models_ExecutionStateType);
};

export type models_State_models_JobStateType = {
    /**
     * Details is a map of additional details about the state.
     */
    Details?: {
        [key: string]: (string);
    };
    /**
     * Message is a human readable message describing the state.
     */
    Message?: string;
    /**
     * StateType is the current state of the object.
     */
    StateType?: (models_JobStateType);
};

export type models_StateChange_models_ExecutionStateType = {
    New?: models_ExecutionStateType;
    Previous?: models_ExecutionStateType;
};

export type models_StateChange_models_JobStateType = {
    New?: models_JobStateType;
    Previous?: models_JobStateType;
};

export type models_Task = {
    Engine?: models_SpecConfig;
    /**
     * Map of environment variables to be used by the driver.
     * Values can be:
     * - Direct value: "debug-mode"
     * - Host env var: "env:HOST_VAR"
     */
    Env?: {
        [key: string]: (string);
    };
    /**
     * InputSources is a list of remote artifacts to be downloaded before running the task
     * and mounted into the task.
     */
    InputSources?: Array<models_InputSource>;
    /**
     * Meta is used to associate arbitrary metadata with this task.
     */
    Meta?: {
        [key: string]: (string);
    };
    /**
     * Name of the task
     */
    Name?: string;
    Network?: models_NetworkConfig;
    Publisher?: models_SpecConfig;
    /**
     * ResourcesConfig is the resources needed by this task
     */
    Resources?: (models_ResourcesConfig);
    /**
     * ResultPaths is a list of task volumes to be included in the task's published result
     */
    ResultPaths?: Array<models_ResultPath>;
    Timeouts?: models_TimeoutConfig;
};

export type models_TimeoutConfig = {
    /**
     * ExecutionTimeout is the maximum amount of time a task is allowed to run in seconds.
     * Zero means no timeout, such as for a daemon task.
     */
    ExecutionTimeout?: number;
    /**
     * QueueTimeout is the maximum amount of time a task is allowed to wait in the orchestrator
     * queue in seconds before being scheduled. Zero means no timeout.
     */
    QueueTimeout?: number;
    /**
     * TotalTimeout is the maximum amount of time a task is allowed to complete in seconds.
     * This includes the time spent in the queue, the time spent executing and the time spent retrying.
     * Zero means no timeout.
     */
    TotalTimeout?: number;
};

export enum selection_Operator {
    DoesNotExist = '!',
    Equals = '=',
    DoubleEquals = '==',
    In = 'in',
    NotEquals = '!=',
    NotIn = 'notin',
    Exists = 'exists',
    GreaterThan = 'gt',
    LessThan = 'lt'
}

export type shared_VersionRequest = {
    client_id?: string;
};

export type shared_VersionResponse = {
    build_version_info?: models_BuildVersionInfo;
};

export type types_API = {
    Auth?: types_AuthConfig;
    /**
     * Host specifies the hostname or IP address on which the API server listens or the client connects.
     */
    Host?: string;
    /**
     * Port specifies the port number on which the API server listens or the client connects.
     */
    Port?: number;
    TLS?: types_TLS;
};

export type types_AuthConfig = {
    /**
     * AccessPolicyPath is the path to a file or directory that will be loaded as
     * the policy to apply to all inbound API requests. If unspecified, a policy
     * that permits access to all API endpoints to both authenticated and
     * unauthenticated users (the default as of v1.2.0) will be used.
     */
    AccessPolicyPath?: string;
    /**
     * Methods maps "method names" to authenticator implementations. A method
     * name is a human-readable string chosen by the person configuring the
     * system that is shown to users to help them pick the authentication method
     * they want to use. There can be multiple usages of the same Authenticator
     * *type* but with different configs and parameters, each identified with a
     * unique method name.
     *
     * For example, if an implementation wants to allow users to log in with
     * Github or Bitbucket, they might both use an authenticator implementation
     * of type "oidc", and each would appear once on this provider with key /
     * method name "github" and "bitbucket".
     *
     * By default, only a single authentication method that accepts
     * authentication via client keys will be enabled.
     */
    Methods?: {
        [key: string]: types_AuthenticatorConfig;
    };
};

export type types_AuthenticatorConfig = {
    PolicyPath?: string;
    Type?: string;
};

export type types_Bacalhau = {
    API?: types_API;
    Compute?: types_Compute;
    /**
     * DataDir specifies a location on disk where the bacalhau node will maintain state.
     */
    DataDir?: string;
    /**
     * DisableAnalytics, when true, disables sharing anonymous analytics data with the Bacalhau development team
     */
    DisableAnalytics?: boolean;
    Engines?: types_EngineConfig;
    FeatureFlags?: types_FeatureFlags;
    InputSources?: types_InputSourcesConfig;
    JobAdmissionControl?: types_JobAdmissionControl;
    JobDefaults?: types_JobDefaults;
    /**
     * Labels are key-value pairs used to describe and categorize the nodes.
     */
    Labels?: {
        [key: string]: (string);
    };
    Logging?: types_Logging;
    /**
     * NameProvider specifies the method used to generate names for the node. One of: hostname, aws, gcp, uuid, puuid.
     */
    NameProvider?: string;
    Orchestrator?: types_Orchestrator;
    Publishers?: types_PublishersConfig;
    ResultDownloaders?: types_ResultDownloaders;
    /**
     * StrictVersionMatch indicates whether to enforce strict version matching.
     */
    StrictVersionMatch?: boolean;
    UpdateConfig?: types_UpdateConfig;
    WebUI?: types_WebUI;
};

export type types_BatchJobDefaultsConfig = {
    /**
     * Priority specifies the default priority allocated to a batch or ops job.
     * This value is used when the job hasn't explicitly set its priority requirement.
     */
    Priority?: number;
    Task?: types_BatchTaskDefaultConfig;
};

export type types_BatchTaskDefaultConfig = {
    Publisher?: types_DefaultPublisherConfig;
    Resources?: types_ResourcesConfig;
    Timeouts?: types_TaskTimeoutConfig;
};

export type types_Cluster = {
    /**
     * Advertise specifies the address to advertise to other cluster members.
     */
    Advertise?: string;
    /**
     * Host specifies the hostname or IP address for cluster communication.
     */
    Host?: string;
    /**
     * Name specifies the unique identifier for this orchestrator cluster.
     */
    Name?: string;
    /**
     * Peers is a list of other cluster members to connect to on startup.
     */
    Peers?: Array<(string)>;
    /**
     * Port specifies the port number for cluster communication.
     */
    Port?: number;
};

export type types_Compute = {
    AllocatedCapacity?: types_ResourceScaler;
    /**
     * AllowListedLocalPaths specifies a list of local file system paths that the compute node is allowed to access.
     */
    AllowListedLocalPaths?: Array<(string)>;
    /**
     * Auth specifies the authentication configuration for compute nodes to connect to the orchestrator.
     */
    Auth?: (types_ComputeAuth);
    /**
     * Enabled indicates whether the compute node is active and available for job execution.
     */
    Enabled?: boolean;
    /**
     * Env specifies environment variable configuration for the compute node
     */
    Env?: (types_EnvConfig);
    Heartbeat?: types_Heartbeat;
    /**
     * Orchestrators specifies a list of orchestrator endpoints that this compute node connects to.
     */
    Orchestrators?: Array<(string)>;
    /**
     * TLS specifies the TLS related configuration on the compute node when connecting with the orchestrator.
     */
    TLS?: (types_ComputeTLS);
};

export type types_ComputeAuth = {
    /**
     * Token specifies the key for compute nodes to be able to access the orchestrator.
     */
    Token?: string;
};

export type types_ComputeTLS = {
    /**
     * CACert specifies the CA file path that the compute node trusts when connecting to orchestrator.
     */
    CACert?: string;
    /**
     * RequireTLS specifies if the compute node enforces encrypted communication with orchestrator.
     */
    RequireTLS?: boolean;
};

export type types_DefaultPublisherConfig = {
    /**
     * Params specifies the publisher configuration data.
     */
    Params?: {
        [key: string]: (string);
    };
    /**
     * Type specifies the publisher type. e.g. "s3", "local", "ipfs", etc.
     */
    Type?: string;
};

export type types_Docker = {
    /**
     * ManifestCache specifies the settings for the Docker manifest cache.
     */
    ManifestCache?: (types_DockerManifestCache);
};

export type types_DockerManifestCache = {
    /**
     * Refresh specifies the refresh interval for cache entries.
     */
    Refresh?: number;
    /**
     * Size specifies the size of the Docker manifest cache.
     */
    Size?: number;
    /**
     * TTL specifies the time-to-live duration for cache entries.
     */
    TTL?: number;
};

export type types_EngineConfig = {
    /**
     * Disabled specifies a list of engines that are disabled.
     */
    Disabled?: Array<(string)>;
    Types?: types_EngineConfigTypes;
};

export type types_EngineConfigTypes = {
    Docker?: types_Docker;
    WASM?: types_WASM;
};

export type types_EnvConfig = {
    /**
     * AllowList specifies which host environment variables can be forwarded to jobs.
     * Supports glob patterns (e.g., "AWS_*", "API_*")
     */
    AllowList?: Array<(string)>;
};

export type types_EvaluationBroker = {
    /**
     * MaxRetryCount specifies the maximum number of times an evaluation can be retried before being marked as failed.
     */
    MaxRetryCount?: number;
    /**
     * VisibilityTimeout specifies how long an evaluation can be claimed before it's returned to the queue.
     */
    VisibilityTimeout?: number;
};

export type types_FeatureFlags = unknown;

export type types_Heartbeat = {
    /**
     * InfoUpdateInterval specifies the time between updates of non-resource information to the orchestrator.
     */
    InfoUpdateInterval?: number;
    /**
     * Interval specifies the time between heartbeat signals sent to the orchestrator.
     */
    Interval?: number;
    /**
     * Deprecated: use Interval instead
     */
    ResourceUpdateInterval?: number;
};

export type types_IPFSPublisher = {
    /**
     * Endpoint specifies the multi-address to connect to for IPFS. e.g /ip4/127.0.0.1/tcp/5001
     */
    Endpoint?: string;
};

export type types_IPFSStorage = {
    /**
     * Endpoint specifies the multi-address to connect to for IPFS. e.g /ip4/127.0.0.1/tcp/5001
     */
    Endpoint?: string;
};

export type types_InputSourcesConfig = {
    /**
     * Disabled specifies a list of storages that are disabled.
     */
    Disabled?: Array<(string)>;
    /**
     * ReadTimeout specifies the maximum number of attempts for reading from a storage.
     */
    MaxRetryCount?: number;
    /**
     * ReadTimeout specifies the maximum time allowed for reading from a storage.
     */
    ReadTimeout?: number;
    Types?: types_InputSourcesTypes;
};

export type types_InputSourcesTypes = {
    IPFS?: types_IPFSStorage;
};

export type types_IpfsDownloader = {
    /**
     * Endpoint specifies the multi-address to connect to for IPFS. e.g /ip4/127.0.0.1/tcp/5001
     */
    Endpoint?: string;
};

export type types_JobAdmissionControl = {
    /**
     * AcceptNetworkedJobs indicates whether to accept jobs that require network access.
     */
    AcceptNetworkedJobs?: boolean;
    /**
     * Locality specifies the locality of the job input data.
     */
    Locality?: (models_JobSelectionDataLocality);
    /**
     * ProbeExec specifies the command to execute for probing job submission.
     */
    ProbeExec?: string;
    /**
     * ProbeHTTP specifies the HTTP endpoint for probing job submission.
     */
    ProbeHTTP?: string;
    /**
     * RejectStatelessJobs indicates whether to reject stateless jobs, i.e. jobs without inputs.
     */
    RejectStatelessJobs?: boolean;
};

export type types_JobDefaults = {
    Batch?: types_BatchJobDefaultsConfig;
    Daemon?: types_LongRunningJobDefaultsConfig;
    Ops?: types_BatchJobDefaultsConfig;
    Service?: types_LongRunningJobDefaultsConfig;
};

export type types_License = {
    /**
     * LocalPath specifies the local license file path
     */
    LocalPath?: string;
};

export type types_LocalPublisher = {
    /**
     * Address specifies the endpoint the publisher serves on.
     */
    Address?: string;
    /**
     * Port specifies the port the publisher serves on.
     */
    Port?: number;
};

export type types_Logging = {
    /**
     * Level sets the logging level. One of: trace, debug, info, warn, error, fatal, panic.
     */
    Level?: string;
    /**
     * LogDebugInfoInterval specifies the interval for logging debug information.
     */
    LogDebugInfoInterval?: number;
    /**
     * Mode specifies the logging mode. One of: default, json.
     */
    Mode?: string;
};

export type types_LongRunningJobDefaultsConfig = {
    /**
     * Priority specifies the default priority allocated to a service or daemon job.
     * This value is used when the job hasn't explicitly set its priority requirement.
     */
    Priority?: number;
    Task?: types_LongRunningTaskDefaultConfig;
};

export type types_LongRunningTaskDefaultConfig = {
    Resources?: types_ResourcesConfig;
};

export type types_NodeManager = {
    /**
     * DisconnectTimeout specifies how long to wait before considering a node disconnected.
     */
    DisconnectTimeout?: number;
    /**
     * ManualApproval, if true, requires manual approval for new compute nodes joining the cluster.
     */
    ManualApproval?: boolean;
};

export type types_Orchestrator = {
    /**
     * Advertise specifies URL to advertise to other servers.
     */
    Advertise?: string;
    /**
     * Auth specifies the authentication configuration for compute nodes to connect to the orchestrator.
     */
    Auth?: (types_OrchestratorAuth);
    Cluster?: types_Cluster;
    /**
     * Enabled indicates whether the orchestrator node is active and available for job submission.
     */
    Enabled?: boolean;
    EvaluationBroker?: types_EvaluationBroker;
    /**
     * Host specifies the hostname or IP address on which the Orchestrator server listens for compute node connections.
     */
    Host?: string;
    /**
     * License specifies license configuration for orchestrator node
     */
    License?: (types_License);
    NodeManager?: types_NodeManager;
    /**
     * Host specifies the port number on which the Orchestrator server listens for compute node connections.
     */
    Port?: number;
    Scheduler?: types_Scheduler;
    /**
     * SupportReverseProxy configures the orchestrator node to run behind a reverse proxy
     */
    SupportReverseProxy?: boolean;
    /**
     * TLS specifies the TLS related configuration on the orchestrator for when compute nodes need to connect.
     */
    TLS?: (types_OrchestratorTLS);
};

export type types_OrchestratorAuth = {
    /**
     * Token specifies the key for compute nodes to be able to access the orchestrator
     */
    Token?: string;
};

export type types_OrchestratorTLS = {
    /**
     * CACert specifies the CA file path that the orchestrator node trusts when connecting to NATS server.
     */
    CACert?: string;
    /**
     * ServerCert specifies the certificate file path given to NATS server to serve TLS connections.
     */
    ServerCert?: string;
    /**
     * ServerKey specifies the private key file path given to NATS server to serve TLS connections.
     */
    ServerKey?: string;
    /**
     * ServerTimeout specifies the TLS timeout, in seconds, set on the NATS server.
     */
    ServerTimeout?: number;
};

export type types_PublisherTypes = {
    IPFS?: types_IPFSPublisher;
    Local?: types_LocalPublisher;
    S3?: types_S3Publisher;
};

export type types_PublishersConfig = {
    /**
     * Disabled specifies a list of publishers that are disabled.
     */
    Disabled?: Array<(string)>;
    Types?: types_PublisherTypes;
};

export type types_ResourceScaler = {
    /**
     * CPU specifies the amount of CPU a compute node allocates for running jobs.
     * It can be expressed as a percentage (e.g., "85%") or a Kubernetes resource string (e.g., "100m").
     */
    CPU?: string;
    /**
     * Disk specifies the amount of Disk space a compute node allocates for running jobs.
     * It can be expressed as a percentage (e.g., "85%") or a Kubernetes resource string (e.g., "10Gi").
     */
    Disk?: string;
    /**
     * GPU specifies the amount of GPU a compute node allocates for running jobs.
     * It can be expressed as a percentage (e.g., "85%") or a Kubernetes resource string (e.g., "1").
     * Note: When using percentages, the result is always rounded up to the nearest whole GPU.
     */
    GPU?: string;
    /**
     * Memory specifies the amount of Memory a compute node allocates for running jobs.
     * It can be expressed as a percentage (e.g., "85%") or a Kubernetes resource string (e.g., "1Gi").
     */
    Memory?: string;
};

export type types_ResourcesConfig = {
    /**
     * CPU specifies the default amount of CPU allocated to a task.
     * It uses Kubernetes resource string format (e.g., "100m" for 0.1 CPU cores).
     * This value is used when the task hasn't explicitly set its CPU requirement.
     */
    CPU?: string;
    /**
     * Disk specifies the default amount of disk space allocated to a task.
     * It uses Kubernetes resource string format (e.g., "1Gi" for 1 gibibyte).
     * This value is used when the task hasn't explicitly set its disk space requirement.
     */
    Disk?: string;
    /**
     * GPU specifies the default number of GPUs allocated to a task.
     * It uses Kubernetes resource string format (e.g., "1" for 1 GPU).
     * This value is used when the task hasn't explicitly set its GPU requirement.
     */
    GPU?: string;
    /**
     * Memory specifies the default amount of memory allocated to a task.
     * It uses Kubernetes resource string format (e.g., "256Mi" for 256 mebibytes).
     * This value is used when the task hasn't explicitly set its memory requirement.
     */
    Memory?: string;
};

export type types_ResultDownloaders = {
    /**
     * Disabled is a list of downloaders that are disabled.
     */
    Disabled?: Array<(string)>;
    /**
     * Timeout specifies the maximum time allowed for a download operation.
     */
    Timeout?: number;
    Types?: types_ResultDownloadersTypes;
};

export type types_ResultDownloadersTypes = {
    IPFS?: types_IpfsDownloader;
};

export type types_S3Publisher = {
    /**
     * PreSignedURLDisabled specifies whether pre-signed URLs are enabled for the S3 provider.
     */
    PreSignedURLDisabled?: boolean;
    /**
     * PreSignedURLExpiration specifies the duration before a pre-signed URL expires.
     */
    PreSignedURLExpiration?: number;
};

export type types_Scheduler = {
    /**
     * HousekeepingInterval specifies how often to run housekeeping tasks.
     */
    HousekeepingInterval?: number;
    /**
     * HousekeepingTimeout specifies the maximum time allowed for a single housekeeping run.
     */
    HousekeepingTimeout?: number;
    /**
     * QueueBackoff specifies the time to wait before retrying a failed job.
     */
    QueueBackoff?: number;
    /**
     * WorkerCount specifies the number of concurrent workers for job scheduling.
     */
    WorkerCount?: number;
};

export type types_TLS = {
    /**
     * AutoCert specifies the domain for automatic certificate generation.
     */
    AutoCert?: string;
    /**
     * AutoCertCachePath specifies the directory to cache auto-generated certificates.
     */
    AutoCertCachePath?: string;
    /**
     * CAFile specifies the path to the Certificate Authority file.
     */
    CAFile?: string;
    /**
     * CertFile specifies the path to the TLS certificate file.
     */
    CertFile?: string;
    /**
     * Insecure allows insecure TLS connections (e.g., self-signed certificates).
     */
    Insecure?: boolean;
    /**
     * KeyFile specifies the path to the TLS private key file.
     */
    KeyFile?: string;
    /**
     * SelfSigned indicates whether to use a self-signed certificate.
     */
    SelfSigned?: boolean;
    /**
     * UseTLS indicates whether to use TLS for client connections.
     */
    UseTLS?: boolean;
};

export type types_TaskTimeoutConfig = {
    /**
     * ExecutionTimeout is the maximum time allowed for task execution
     */
    ExecutionTimeout?: number;
    /**
     * TotalTimeout is the maximum total time allowed for a task
     */
    TotalTimeout?: number;
};

export type types_UpdateConfig = {
    /**
     * Interval specifies the time between update checks, when set to 0 update checks are not performed.
     */
    Interval?: number;
};

export type types_WASM = unknown;

export type types_WebUI = {
    /**
     * Backend specifies the address and port of the backend API server.
     * If empty, the Web UI will use the same address and port as the API server.
     */
    Backend?: string;
    /**
     * Enabled indicates whether the Web UI is enabled.
     */
    Enabled?: boolean;
    /**
     * Listen specifies the address and port on which the Web UI listens.
     */
    Listen?: string;
};

export type HomeResponse = (string);

export type HomeError = unknown;

export type IdResponse = (string);

export type IdError = (string);

export type LivezResponse = (string);

export type LivezError = unknown;

export type NodeInfoResponse = (models_NodeInfo);

export type NodeInfoError = (string);

export type AgentAliveResponse = (apimodels_IsAliveResponse);

export type AgentAliveError = unknown;

export type AgentConfigResponse = (types_Bacalhau);

export type AgentConfigError = (string);

export type AgentDebugResponse = (models_DebugInfo);

export type AgentDebugError = (string);

export type AgentLicenseResponse = (apimodels_GetAgentLicenseResponse);

export type AgentLicenseError = (string);

export type AgentNodeResponse = (models_NodeInfo);

export type AgentNodeError = (string);

export type AgentVersionResponse = (apimodels_GetVersionResponse);

export type AgentVersionError = (string);

export type ApiServerDebugResponse = (string);

export type ApiServerDebugError = (string);

export type OrchestratorListJobsData = {
    query?: {
        /**
         * Limit the number of jobs returned
         */
        limit?: number;
        /**
         * Namespace to get the jobs for
         */
        namespace?: string;
        /**
         * Token to get the next page of jobs
         */
        next_token?: string;
        /**
         * Order the jobs by the given field
         */
        order_by?: string;
        /**
         * Reverse the order of the jobs
         */
        reverse?: boolean;
    };
};

export type OrchestratorListJobsResponse = (apimodels_ListJobsResponse);

export type OrchestratorListJobsError = (string);

export type OrchestratorPutJobData = {
    /**
     * Job to submit
     */
    body: apimodels_PutJobRequest;
};

export type OrchestratorPutJobResponse = (apimodels_PutJobResponse);

export type OrchestratorPutJobError = (string);

export type OrchestratorGetJobData = {
    path: {
        /**
         * ID to get the job for
         */
        id: string;
    };
    query?: {
        /**
         * Takes history and executions as options. If empty will not include anything else.
         */
        include?: string;
        /**
         * Number of history or executions to fetch. Should be used in conjugation with include
         */
        limit?: number;
    };
};

export type OrchestratorGetJobResponse = (apimodels_GetJobResponse);

export type OrchestratorGetJobError = (string);

export type OrchestratorStopJobData = {
    path: {
        /**
         * ID to stop the job for
         */
        id: string;
    };
    query?: {
        /**
         * Reason for stopping the job
         */
        reason?: string;
    };
};

export type OrchestratorStopJobResponse = (apimodels_StopJobResponse);

export type OrchestratorStopJobError = (string);

export type OrchestratorJobExecutionsData = {
    path: {
        /**
         * ID to get the job executions for
         */
        id: string;
    };
    query: {
        /**
         * Limit the number of executions returned
         */
        limit?: number;
        /**
         * Namespace to get the jobs for
         */
        namespace?: string;
        /**
         * Token to get the next page of executions
         */
        next_token?: string;
        /**
         * Order the executions by the given field
         */
        order_by: string;
        /**
         * Reverse the order of the executions
         */
        reverse?: boolean;
    };
};

export type OrchestratorJobExecutionsResponse = (apimodels_ListJobExecutionsResponse);

export type OrchestratorJobExecutionsError = (string);

export type OrchestratorListHistoryData = {
    path: {
        /**
         * ID to get the job history for
         */
        id: string;
    };
    query?: {
        /**
         * Only return history of this event type
         */
        event_type?: string;
        /**
         * Only return history of this execution ID
         */
        execution_id?: string;
        /**
         * Token to get the next page of the history events
         */
        next_token?: string;
        /**
         * Only return history since this time
         */
        since?: string;
    };
};

export type OrchestratorListHistoryResponse = (apimodels_ListJobHistoryResponse);

export type OrchestratorListHistoryError = (string);

export type OrchestratorLogsData = {
    path: {
        /**
         * ID of the job to stream logs for
         */
        id: string;
    };
    query?: {
        /**
         * Fetch logs for a specific execution
         */
        execution_id?: string;
        /**
         * Follow the logs
         */
        follow?: boolean;
        /**
         * Fetch historical logs
         */
        tail?: boolean;
    };
};

export type OrchestratorJobResultsData = {
    path: {
        /**
         * ID to get the job results for
         */
        id: string;
    };
};

export type OrchestratorJobResultsResponse = (apimodels_ListJobResultsResponse);

export type OrchestratorJobResultsError = (string);

export type OrchestratorListNodesData = {
    query?: {
        /**
         * Filter Approval
         */
        filter_approval?: string;
        /**
         * Filter Status
         */
        'filter-status'?: string;
        /**
         * Limit the number of node returned
         */
        limit?: number;
        /**
         * Token to get the next page of nodes
         */
        next_token?: string;
        /**
         * Order the nodes by given field
         */
        order_by?: string;
        /**
         * Reverse the order of the nodes
         */
        reverse?: boolean;
    };
};

export type OrchestratorListNodesResponse = (apimodels_ListNodesResponse);

export type OrchestratorListNodesError = (string);

export type OrchestratorUpdateNodeData = {
    /**
     * Put Node Request
     */
    body: apimodels_PutNodeRequest;
    path: {
        /**
         * ID of the orchestrator node.
         */
        id: string;
    };
};

export type OrchestratorUpdateNodeResponse = (apimodels_PutNodeResponse);

export type OrchestratorUpdateNodeError = (string);

export type OrchestratorGetNodeData = {
    path: {
        /**
         * ID of the orchestrator node to fetch for.
         */
        id: string;
    };
};

export type OrchestratorGetNodeResponse = (apimodels_GetNodeResponse);

export type OrchestratorGetNodeError = (string);

export type ApiServerVersionData = {
    /**
     * Request must specify a `client_id`. To retrieve your `client_id`, you can do the following: (1) submit a dummy job to Bacalhau (or use one you created before), (2) run `bacalhau describe <job-id>` and fetch the `ClientID` field.
     */
    body: shared_VersionRequest;
};

export type ApiServerVersionResponse = (shared_VersionResponse);

export type ApiServerVersionError = (string);